{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/utils.js", "../../src/dom-diff.js", "../../src/store.js", "../../src/html.js"],
  "sourcesContent": ["// utils\nimport {\n\tfrom,\n\tobjectAssign,\n\teach,\n\tisCustomElement\n} from './utils.js';\nimport { patchDom } from './dom-diff.js';\nimport { Store } from './store.js';\nimport { html } from './html.js';\n\n// Deep merge helper\nfunction merge(out) {\n\tout = out || {};\n\tfor (var argIndex = 1; argIndex < arguments.length; argIndex++) {\n\t\tvar obj = arguments[argIndex];\n\t\tif (!obj || typeof val !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\t\tvar keys = keys(obj);\n\t\tfor (var keyIndex = 1; keyIndex < keys.length; keyIndex++) {\n\t\t\tvar key = keys[keyIndex];\n\t\t\tvar val = obj[key];\n\t\t\tout[key] = (typeof val === 'object' && val !== null)\n\t\t\t\t? merge(out[key], val)\n\t\t\t\t: val;\n\t\t}\n\t}\n\treturn out;\n}\n/**\n * Converts html string to a document fragment.\n * @param {String} html\n * @return {DocumentFragment}\n * @method dom\n */\nfunction parseAsFragment(html) {\n\tvar templateTag = document.createElement('template');\n\ttemplateTag.innerHTML = html;\n\treturn templateTag.content;\n}\n\n/**\n * Traverse elements of a tree in order of visibility (pre-order traversal)\n * @param {Node} parentNode\n * @param {(Node) => void} onNextNode\n */\nfunction traverseElements(parentNode, onNextNode) {\n\tvar treeWalker = document.createTreeWalker(parentNode, NodeFilter.SHOW_ELEMENT),\n\t\t\tnode = treeWalker.nextNode();\n\twhile (node) {\n\t\t// dont touch the inner nodes of custom elements\n\t\tif (isCustomElement(node)) {\n\t\t\tnode = treeWalker.nextSibling();\n\t\t\tcontinue;\n\t\t}\n\t\tonNextNode(node);\n\t\tnode = treeWalker.nextNode();\n\t}\n}\n\n/**\n * @template DataType\n * @param {Object} config \n * @param {HTMLElement} config.target\n * @param {DataType} config.data\n * @param {(data: DataType) => String} config.getHtml\n * @param {Boolean} [config.mount=false]\n * @param {Boolean} [config.hydrate=false]\n * @param {{ store: Store, props: String[] }} [config.connect]\n */\nfunction Pepper(config) {\n\tvar self = this;\n\tself._data = (typeof config.data === 'object' && config.data) || {};\n\tvar mount = config.mount;\n\tvar hydrate = config.hydrate;\n\t\n\tdelete config.data;\n\tdelete config.mount;\n\tdelete config.hydrate;\n\tobjectAssign(self, config);\n\tObject.defineProperty(self, 'data', {\n\t\tconfigurable: false,\n\t\tset(data) {\n\t\t\tself._data = data;\n\t\t\t// TODO: only render if there is a change\n\t\t\tself.render();\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n\tif (hydrate) {\n\t\tself.hydrate()\n\t} else if (mount) {\n\t\tself.mount();\n\t}\n}\n\n// private\nvar handlerMap = new WeakMap();\n/**\n * Helper to attach handleEvent object event listener to element.\n * @param {HTMLElement} node\n * @param {Object} context\n * @param {String} eventName\n * @param {Function} func\n */\nfunction attachHandler(node, context, eventName, func) {\n\tif (!func) return;\n\tvar newMap = handlerMap.get(node) || {};\n\tnewMap[eventName] = func;\n\thandlerMap.set(node, newMap);\n\tnode.addEventListener(eventName, context);\n}\n/**\n * Removes all event handlers on node. Ensure same context is passed as it\n * was for attachHandler() function, else the event listeners wont get removed.\n */\nfunction removeAllHandlers(node, context) {\n\tObject.keys(handlerMap.get(node) || {}).forEach(function (eventName) {\n\t\tnode.removeEventListener(eventName, context);\n\t});\n\thandlerMap.delete(node);\n}\n/**\n * Invokes an event handler that was registered via attachHandler\n * @param {Pepper} context \n * @param {Event} event \n */\nfunction callHandler(context, event) {\n\tvar node = event.currentTarget;\n\tvar func = (handlerMap.get(node) || {})[event.type];\n\tif (func) {\n\t\tfunc.call(context, event);\n\t}\n}\n\n// Methods and properties\nPepper.prototype = {\n\t/**\n\t * The data object.\n\t * This is a private variable accessed through this.data\n\t * setter/getter.\n\t */\n\t_data: null,\n\n\t/**\n\t * (Optional) The element to replace (on first render).\n\t */\n\ttarget: null,\n\n\t/**\n\t * (Optional) A Pepper store and array of props to listen to. The properties will be mixed with\n\t * `data` passed to this.getHtml() function (in case of collision local data takes precedence\n\t * over store data). This instance will re-render (when mounted) when the specified props change\n\t * in the global store\n\t * Example: ['cart', 'wishlist']\n\t * @type {{\n\t * \tstore: Pepper.Store,\n\t *  props: string[]\n\t * }}\n\t */\n\tconnect: {},\n\n\t/**\n\t * Function that returns component's html to be rendered\n\t * @param {any} data combined data from this.data and connected pepper store data\n\t * @returns {string}\n\t */\n\tgetHtml() { return ''; },\n\t\n\t/**\n\t * Set data on this.data (using Object.assign), and re-render.\n\t */\n\tassign() {\n\t\tvar args = from(arguments);\n\t\tobjectAssign.apply(null, [this.data].concat(args));\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\t/**\n\t * Deep merge data with this.data, and re-render.\n\t */\n\tmerge(data) {\n\t\tmerge(this.data, data);\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\thandleEvent(event) {\n\t\tcallHandler(this, event);\n\t},\n\n\ttoString: function renderToString() {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tvar storeData = (connect && connect.store && connect.store._data) || {};\n\t\tvar storeDataSubset = ((connect && connect.props) || []).reduce((acc, prop) => {\n\t\t\tacc[prop] = storeData[prop];\n\t\t\treturn acc;\n\t\t}, {});\n\t\tvar data = objectAssign(storeDataSubset, self.data);\n\t\treturn self.getHtml(data);\n\t},\n\n\t/**\n\t * Render view.\n\t * If this.target or node parameter is specified, then replaces that node and attaches the\n\t * rendered DOM to document (or document fragment).\n\t *\n\t * @private\n\t */\n\trender() {\n\t\t// Step 1: Remove event listeners and refs\n\t\t// Step 2: Note the currently focused element\n\t\t// Step 3: Render/Update UI.\n\t\t// Step 4: Resolve references\n\t\t// Step 5: Re-focus\n\t\t// Step 6: Re-attach listeners\n\t\t\n\t\tvar self = this;\n\t\tvar target = self.el;\n\n\t\t// Step 1: Find input field focus, remember it's id attribute, so that it\n\t\t// can be refocused later.\n\t\tvar focusId = document.activeElement.id;\n\n\t\t// Step 2: Remove event listeners and refs before patch.\n\t\tif (target) {\n\t\t\ttraverseElements(target, (node) => {\n\t\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\t\tif (refVal && self[refVal] instanceof Node) {\n\t\t\t\t\tdelete self[refVal];\n\t\t\t\t}\n\t\t\t\tif (handlerMap.has(node)) {\n\t\t\t\t\tremoveAllHandlers(node, self);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Step 3: Render/Update UI\n\t\tvar frag = parseAsFragment(self.toString());\n\t\tvar els = from(frag.childNodes)\n\t\t// var el = frag.firstElementChild;\n\n\t\t// Update existing DOM.\n\t\tif (target) {\n\t\t\tvar live = from(target.childNodes);\n\t\t\tpatchDom(els, live, target);\n\t\t}\n\n\t\t// Step 4: Re-focus\n\t\tif (focusId) {\n\t\t\tvar focusEl = document.getElementById(focusId);\n\t\t\tif (focusEl) {\n\t\t\t\tfocusEl.focus();\n\t\t\t}\n\t\t}\n\n\t\tself.domHydrate();\n\t},\n\n\t/**\n\t * @private\n\t */\n\tdomHydrate() {\n\t\t// Doing step 5 and 6 from render() function\n\t\t// Step 5: Resolve refs\n\t\t// Step 6: Attach event listeners\n\n\t\tvar self = this;\n\t\t// TODO: only set this on debug mode\n\t\tself.el.pepperInstance = self;\n\n\t\t// Note: ref creates a reference to the node as property on the view.\n\t\ttraverseElements(self.el, (node) => {\n\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\tif (refVal) {\n\t\t\t\tself[refVal] = node;\n\t\t\t}\n\t\t\teach(node.attributes, (attr) => {\n\t\t\t\tif (attr.name.startsWith('on-')) {\n\t\t\t\t\tvar eventName = attr.name.replace(/on-/, '');\n\t\t\t\t\tattachHandler(node, self, eventName, self[attr.value]);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * @param {Boolean} [hydrateOnly=false] does a full render by default. 'Hydration' only\n\t * attaches event listeners and resolves refs.\n\t * @returns \n\t */\n\tmount(hydrateOnly = false) {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tif (connect && connect.store) {\n\t\t\tconnect.store.subscribe(connect.props, self.render, self);\n\t\t}\n\n\t\tvar node = self.target;\n\t\tif (typeof node === 'string') {\n\t\t\tnode = document.querySelector(node);\n\t\t}\n\n\t\t// Return if already mounted.\n\t\tif (self.el && node === self.el) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node) {\n\t\t\tself.el = node;\n\t\t\tif (hydrateOnly) {\n\t\t\t\tself.domHydrate();\n\t\t\t} else { // full render\n\t\t\t\tself.render();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\thydrate(data) {\n\t\tif (arguments.length > 0 && data && typeof data === 'object') {\n\t\t\tthis._data = data;\n\t\t}\n\t\tthis.mount(true);\n\t},\n\n\tunmount() {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tif (connect && connect.store) {\n\t\t\tconnect.store.unsubscribe(self.render, self);\n\t\t}\n\t\tself.el.replaceChildren(); // empty replaceChildren removes all child elements\n\t}\n};\n\nexport { Pepper, Store, html };\n", "var from = Array.from;\n\nfunction each(arrayLike, fn) {\n\treturn Array.prototype.forEach.call(arrayLike, fn);\n}\n\nfunction isCustomElement(element) {\n\tif (element.tagName.indexOf('-') > 0) return true;\n\tvar attr = element.getAttribute('is');\n\treturn (attr && attr.indexOf('-') > 0);\n}\n\nfunction keys(obj) {\n\treturn Object.keys(obj).filter(key => key !== 'constructor');\n}\n// Safer Object.assign\nfunction objectAssign(target) {\n\tfrom(arguments).forEach((obj, index) => {\n\t\tif (!index) return;\n\t\tkeys(obj).forEach((key) => {\n\t\t\ttarget[key] = obj[key];\n\t\t});\n\t});\n\treturn target;\n}\n\nexport {\n  each,\n  isCustomElement,\n  from,\n  keys,\n  objectAssign,\n};", "import { from, each, isCustomElement } from './utils.js';\n\n/**\n * @param {Element} newNode\n * @param {Element} liveNode\n */\nfunction syncAttributes(newNode, liveNode) {\n\t// Remove any attributes from live node that is not in new node\n\teach(liveNode.attributes, (attr) => {\n\t\tif (!newNode.attributes.getNamedItem(attr.name)) {\n\t\t\tliveNode.attributes.removeNamedItem(attr.name);\n\t\t}\n\t});\n\n\t// update the rest\n\teach(newNode.attributes, (attr) => {\n\t\tif (liveNode.getAttribute(attr.name) !== attr.value) {\n\t\t\tliveNode.setAttribute(attr.name, attr.value);\n\t\t}\n\t});\n}\n\nfunction getCustomElementOuterHtml(el) {\n\treturn el.outerHTML.slice(0, -(el.innerHTML.length + el.tagName.length + 4)) + '/>';\n}\n/**\n * \n * @param {Node} node \n * @param {Map<Node, string>} cache \n * @returns {string}\n */\nfunction hashNode(node, cache) {\n\tvar hash = cache.get(node);\n\tif (!hash) {\n\t\thash = node.nodeType + ':' + (\n\t\t\t(node.nodeType === 1 ?\n\t\t\t\t(\n\t\t\t\t\tisCustomElement(node) ?\n\t\t\t\t\tgetCustomElementOuterHtml(node) :\n\t\t\t\t\t/** @type {Element} */ (node).outerHTML\n\t\t\t\t) :\n\t\t\t\t// comment, text, cdata node\n\t\t\t\tnode.nodeValue\n\t\t\t)\n\t\t);\n\t\tcache.set(node, hash);\n\t}\n\treturn hash;\n}\n\n/**\n * Assumptions:\n * 1. liveNodes are child nodes of parentNode\n * 2. no duplicates allowed within newNodes\n * 3. no duplicates allowed within liveNodes\n * 4. neither list should contain `after` node or any node before `after` node\n * @param {Node[]} newNodes\n * @param {Node[]} liveNodes\n * @param {Node} parentNode\n * @param {Node} [after] sync nodes after a specified node, so that the nodes before it doesn't get touched\n */\nfunction patchDom(newNodes, liveNodes, parentNode, after) {\n\n\t// fast path: case if newNodes.length is zero. means remove all\n\tif (!newNodes.length) {\n\t\tliveNodes.forEach(node => parentNode.removeChild(node));\n\t\treturn;\n\t}\n\n\t/** @type {Map<Node, string>} */\n\tvar nodeHashCache = new Map();\n\n\t/**\n\t * @typedef DomInfo\n\t * @property {Node[]} u unmatched\n\t * @property {Map<Node, Node>} n2l new node to live lookup\n\t */\n\t/**\n\t * Map from new nodes to old and back if available\n\t * @type {Record<string, DomInfo>}\n\t */\n\tvar domLookup = {};\n\tnewNodes.forEach((newNode) => {\n\t\tvar hash = hashNode(newNode, nodeHashCache);\n\t\tdomLookup[hash] = domLookup[hash] || {\n\t\t\tu: [],\n\t\t\tn2l: new Map(),\n\t\t};\n\t\tdomLookup[hash].u.push(newNode);\n\t});\n\t/**\n\t * we later want to re-use elements that don't have exact match if we can\n\t * @type {Record<string, Element[]>}\n\t */\n\tvar salvagableElements = {};\n\tliveNodes.forEach((liveNode) => {\n\t\tvar hash = hashNode(liveNode, nodeHashCache);\n\t\tvar entry = domLookup[hash];\n\t\tvar matched = false;\n\t\tif (entry) {\n\t\t\tvar newNode = entry.u.shift(); // pick first match\n\t\t\tif (newNode) {\n\t\t\t\tentry.n2l.set(newNode, liveNode);\n\t\t\t\tmatched = true;\n\t\t\t}\n\t\t}\n\t\tif (!matched && liveNode.nodeType === 1) {\n\t\t\tsalvagableElements[liveNode.nodeName] = salvagableElements[liveNode.nodeName] || [];\n\t\t\tsalvagableElements[liveNode.nodeName].push(/** @type {Element} */ (liveNode));\n\t\t}\n\t});\n\n\t// figure out where to start syncing from\n\tvar insertAt = from(parentNode.childNodes).indexOf(after) + 1;\n\tvar newLiveNodes = new Set();\n\n\t// re-ordering\n\t// we now look at new nodes top-to-bottom and order them exactly at it's final index\n\tnewNodes.forEach((newNode, index) => {\n\t\t// check for exact match live node\n\t\tvar hash = hashNode(newNode, nodeHashCache);\n\t\tvar existingLiveNode = domLookup[hash].n2l.get(newNode);\n\t\tvar nodeAtPosition = parentNode.childNodes[insertAt + index];\n\t\tif (existingLiveNode) {\n\t\t\tnewLiveNodes.add(existingLiveNode);\n\t\t\t// place it at the position. If nodeAtPosition is undefined, then inserts to end\n\t\t\tif (nodeAtPosition !== existingLiveNode) {\n\t\t\t\tparentNode.insertBefore(existingLiveNode, nodeAtPosition);\n\t\t\t}\n\t\t\t// else nothing to do if exact match is already at the right position\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// at this point we don't have an exact match node.\n\t\t// So for text, comment nodes just use the new nodes.\n\t\t// But for elements we can potentially re-use an existing element\n\t\t//\n\t\t// why? because there is a likely hood the node to be updated is a\n\t\t// \"similar looking\" element.\n\t\t// e.g. if the only update was an attribute update, and that node\n\t\t// happens to be a input element, it is worth keeping it so that\n\t\t// user doesn't potentially lose focus\n\n\t\tvar newNodeName = newNode.nodeName;\n\t\tif (\n\t\t\tnewNode.nodeType === 1\n\t\t\t&& (salvagableElements[newNodeName] && salvagableElements[newNodeName].length)\n\t\t) {\n\t\t\t// at this point we have an element that doesn't have an exact matching node.\n\t\t\t// but we do have an existing element of same nodeType that can be re-used\n\t\t\tvar newEl = /** @type {Element} */ (newNode); // gah, typescript!\n\t\t\tvar aLiveNode = salvagableElements[newNode.nodeName].shift(); // pick first one\n\t\t\tnewLiveNodes.add(aLiveNode);\n\t\t\t// place it at where the new node should be\n\t\t\tif (nodeAtPosition !== aLiveNode) {\n\t\t\t\tparentNode.insertBefore(aLiveNode, nodeAtPosition);\n\t\t\t}\n\t\t\tsyncAttributes(newEl, aLiveNode);\n\t\t\t// recursively sync children if innerHTML is different, except\n\t\t\t// custom elements (because encapsulation. reactivity with CE is via attributes only)\n\t\t\tif (!isCustomElement(newEl) && newEl.innerHTML != aLiveNode.innerHTML) {\n\t\t\t\tpatchDom(\n\t\t\t\t\tfrom(newEl.childNodes),\n\t\t\t\t\tfrom(aLiveNode.childNodes),\n\t\t\t\t\taLiveNode,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// At this point the node is either a text node, comment node or\n\t\t// an element that cant re-use another element.\n\t\tnewLiveNodes.add(newNode);\n\t\tparentNode.insertBefore(newNode, nodeAtPosition);\n\t});\n\n\t// now remove any element not in newLiveNodes\n\tliveNodes.forEach((node) => {\n\t\tif (!newLiveNodes.has(node)) {\n\t\t\tparentNode.removeChild(node);\n\t\t}\n\t});\n}\n\nexport { patchDom };", "import { keys, objectAssign } from './utils.js'\n\n// A store for Pepper views\n// it only does a shallow (i.e level 1) equality check of the store data properties\n// for notifying relevant connected views to re-render\n/**\n * @constructor\n * @param {Object} initialData\n */\nfunction Store(initialData) {\n\tvar self = this;\n\t/** @private */\n\tself._data = initialData || {};\n\t/** @private */\n\tself._subscribers = [];\n\n\tObject.defineProperty(this, 'data', {\n\t\tconfigurable: false,\n\t\tset(newData) {\n\t\t\tif (typeof newData !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar changedProps = [].concat(\n\t\t\t\t// find props that were changed\n\t\t\t\tkeys(newData).filter((prop) => self._data[prop] !== newData[prop]),\n\t\t\t\t// find props that got removed (i.e. not in new data)\n\t\t\t\tkeys(self._data).filter((prop) => !(prop in newData))\n\t\t\t);\n\t\t\tself._data = newData;\n\t\t\tself.notify(changedProps);\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n}\n\nStore.prototype = {\n\t/**\n\t * Reactive data - Getter/Setter\n\t */\n\tdata: {},\n\t/**\n\t * @private\n\t */\n\tnotify(changedProps) {\n\t\tvar changedPropsLookup = changedProps.reduce((acc, prop) => {\n\t\t\tacc[prop] = 1;\n\t\t\treturn acc;\n\t\t}, {});\n\t\tthis._subscribers.forEach((subscriber) => {\n\t\t\tvar changesPropsSubset = subscriber.props.filter((prop) => changedPropsLookup[prop]);\n\t\t\tif (changesPropsSubset.length) {\n\t\t\t\tsubscriber.callback.call(subscriber.context, changesPropsSubset);\n\t\t\t}\n\t\t});\n\t},\n\t/**\n\t * Subscribe to changes in global store properties\n\t * @param {string[]} propsToListenFor\n\t * @param {() => undefined} func\n\t * @param {any} [context]\n\t * @returns \n\t */\n\tsubscribe(propsToListenFor, func, context) {\n\t\tif (typeof func !== 'function' || !Array.isArray(propsToListenFor)) {\n\t\t\treturn;\n\t\t}\n\t\tvar self = this;\n\t\tvar alreadyAdded = self._subscribers.some((subscriber) => (\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t\tif (!alreadyAdded) {\n\t\t\tself._subscribers.push({\n\t\t\t\tprops: propsToListenFor,\n\t\t\t\tcallback: func,\n\t\t\t\tcontext: context\n\t\t\t});\n\t\t}\n\t},\n\tunsubscribe(func, context) {\n\t\tthis._subscribers = this._subscribers.filter((subscriber) => !(\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t},\n\tassign(newData) {\n\t\tvar self = this;\n\t\tif (typeof newData !== 'object') {\n\t\t\treturn;\n\t\t}\n\t\tvar changedProps = keys(newData).filter((prop) => self._data[prop] !== newData[prop]);\n\t\tobjectAssign(self._data, newData);\n\t\tself.notify(changedProps);\n\t}\n};\n\nexport { Store };", "const characterEntitiesMapping = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '&': '&amp;',\n  \"'\": '&apos;',\n  '\"': '&quot;',\n};\nfunction escape(text) {\n  if (!text) return text;\n  return text.replace(/[<>&'\"]/g, character => characterEntitiesMapping[character]);\n}\n// Utility for users not using a template library\nfunction html(strings, ...values) {\n  return strings.reduce((acc, string, index) => {\n    let value = String(values[index - 1]);\n    if ((strings[index - 1] || '').endsWith(\"$\")) {\n      // If $ sign precedes the interpolation, then its considered safe to\n      // add the unescaped / raw HTML\n      acc = acc.slice(0, -1);\n    } else {\n      value = escape(value);\n    }\n    return acc + value + string;\n  });\n}\n\nexport { html };"],
  "mappings": "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",
  "names": ["keys", "html"]
}
