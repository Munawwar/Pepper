{
  "version": 3,
  "sources": ["../../src/index.js", "../../src/utils.js", "../../src/dom-diff.js", "../../src/store.js", "../../src/html.js"],
  "sourcesContent": ["// utils\nimport {\n\tfrom,\n\tobjectAssign,\n\teach,\n\tisCustomElement,\n\tkeys\n} from './utils.js';\nimport { patchDom } from './dom-diff.js';\nimport { Store } from './store.js';\nimport { html } from './html.js';\n\n// Deep merge helper\nfunction merge(out) {\n\tout = out || {};\n\tfor (var argIndex = 1; argIndex < arguments.length; argIndex++) {\n\t\tvar obj = arguments[argIndex];\n\t\tif (!obj || typeof val !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\t\tvar keys = keys(obj);\n\t\tfor (var keyIndex = 1; keyIndex < keys.length; keyIndex++) {\n\t\t\tvar key = keys[keyIndex];\n\t\t\tvar val = obj[key];\n\t\t\tout[key] = (typeof val === 'object' && val !== null)\n\t\t\t\t? merge(out[key], val)\n\t\t\t\t: val;\n\t\t}\n\t}\n\treturn out;\n}\n/**\n * Converts html string to a document fragment.\n * @param {String} html\n * @return {DocumentFragment}\n * @method dom\n */\nfunction parseAsFragment(html) {\n\tvar templateTag = document.createElement('template');\n\ttemplateTag.innerHTML = html;\n\treturn templateTag.content;\n}\n\n/**\n * Traverse elements of a tree in order of visibility (pre-order traversal)\n * @param {Node} parentNode\n * @param {(Node) => void} onNextNode\n */\nfunction traverseElements(parentNode, onNextNode) {\n\tvar treeWalker = document.createTreeWalker(parentNode, NodeFilter.SHOW_ELEMENT),\n\t\t\tnode = treeWalker.nextNode();\n\twhile (node) {\n\t\t// dont touch the inner nodes of custom elements\n\t\tif (isCustomElement(node)) {\n\t\t\tnode = treeWalker.nextSibling();\n\t\t\tcontinue;\n\t\t}\n\t\tonNextNode(node);\n\t\tnode = treeWalker.nextNode();\n\t}\n}\n\n/**\n * @template DataType\n * @param {Object} config \n * @param {HTMLElement} config.target\n * @param {DataType} config.data\n * @param {(data: DataType) => String} config.getHtml\n * @param {Boolean} [config.mount=false]\n * @param {Boolean} [config.hydrate=false]\n * @param {{ [storeKey: string]: { store: Store, props: String[] } }|null} [config.stores]\n */\nfunction Pepper(config) {\n\tvar self = this;\n\tself._data = (typeof config.data === 'object' && config.data) || {};\n\tvar mount = config.mount;\n\tvar hydrate = config.hydrate;\n\t\n\tdelete config.data;\n\tdelete config.mount;\n\tdelete config.hydrate;\n\tobjectAssign(self, config);\n\tObject.defineProperty(self, 'data', {\n\t\tconfigurable: false,\n\t\tset(data) {\n\t\t\tself._data = data;\n\t\t\t// TODO: only render if there is a change\n\t\t\tself.render();\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n\tif (hydrate) {\n\t\tself.hydrate()\n\t} else if (mount) {\n\t\tself.mount();\n\t}\n}\n\n// private\nvar handlerMap = new WeakMap();\n/**\n * Helper to attach handleEvent object event listener to element.\n * @param {HTMLElement} node\n * @param {Object} context\n * @param {String} eventName\n * @param {Function} func\n */\nfunction attachHandler(node, context, eventName, func) {\n\tif (!func) return;\n\tvar newMap = handlerMap.get(node) || {};\n\tnewMap[eventName] = func;\n\thandlerMap.set(node, newMap);\n\tnode.addEventListener(eventName, context);\n}\n/**\n * Removes all event handlers on node. Ensure same context is passed as it\n * was for attachHandler() function, else the event listeners wont get removed.\n */\nfunction removeAllHandlers(node, context) {\n\tObject.keys(handlerMap.get(node) || {}).forEach((eventName) => {\n\t\tnode.removeEventListener(eventName, context);\n\t});\n\thandlerMap.delete(node);\n}\n/**\n * Invokes an event handler that was registered via attachHandler\n * @param {Pepper} context \n * @param {Event} event \n */\nfunction callHandler(context, event) {\n\tvar node = event.currentTarget;\n\tvar func = (handlerMap.get(node) || {})[event.type];\n\tif (func) {\n\t\tfunc.call(context, event);\n\t}\n}\n\n// Methods and properties\nPepper.prototype = {\n\t/**\n\t * The data object.\n\t * This is a private variable accessed through this.data\n\t * setter/getter.\n\t */\n\t_data: null,\n\n\t/**\n\t * (Optional) The element to replace (on first render).\n\t */\n\ttarget: null,\n\n\t/**\n\t * (Optional) A Pepper store and array of props to listen to. The properties will be added to\n\t * `data.stores` passed to this.getHtml() function.\n\t * This instance will re-render (when mounted) when the specified props change in the store\n\t * Example: ['cart', 'wishlist']\n\t * @type {{\n\t * \t[storeKey: string]: {\n\t * \t  store: Store,\n\t *    props: string[]\n\t *  }\n\t * }|null}\n\t */\n\tstores: null,\n\n\t/**\n\t * Function that returns component's html to be rendered\n\t * @param {any} data combined data from this.data and subscribed stores\n\t * @returns {string}\n\t */\n\tgetHtml() { return ''; },\n\t\n\t/**\n\t * Set data on this.data (using Object.assign), and re-render.\n\t */\n\tassign() {\n\t\tvar args = from(arguments);\n\t\tobjectAssign.apply(null, [this.data].concat(args));\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\t/**\n\t * Deep merge data with this.data, and re-render.\n\t */\n\tmerge(data) {\n\t\tmerge(this.data, data);\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\thandleEvent(event) {\n\t\tcallHandler(this, event);\n\t},\n\n\ttoString: function renderToString() {\n\t\tvar self = this;\n\t\tvar stores = self.stores;\n\t\tconst storeData = keys(stores).reduce((acc, storeKey) => {\n\t\t\tvar { store, props } = stores[storeKey];\n\t\t\tvar storeData = (store && store._data) || {};\n\t\t\tacc[storeKey] = (props || []).reduce((acc2, prop) => {\n\t\t\t\tacc2[prop] = storeData[prop];\n\t\t\t\treturn acc2;\n\t\t\t}, {});\n\t\t\treturn acc;\n\t\t}, {});\n\t\tvar data = objectAssign({ stores: storeData }, self.data);\n\t\treturn self.getHtml(data);\n\t},\n\n\t/**\n\t * Render view.\n\t * If this.target or node parameter is specified, then replaces that node and attaches the\n\t * rendered DOM to document (or document fragment).\n\t *\n\t * @private\n\t */\n\trender() {\n\t\t// Step 1: Remove event listeners and refs\n\t\t// Step 2: Note the currently focused element\n\t\t// Step 3: Render/Update UI.\n\t\t// Step 4: Resolve references\n\t\t// Step 5: Re-focus\n\t\t// Step 6: Re-attach listeners\n\t\t\n\t\tvar self = this;\n\t\tvar target = self.el;\n\n\t\t// Step 1: Find input field focus, remember it's id attribute, so that it\n\t\t// can be refocused later.\n\t\tvar focusId = document.activeElement.id;\n\n\t\t// Step 2: Remove event listeners and refs before patch.\n\t\tif (target) {\n\t\t\ttraverseElements(target, (node) => {\n\t\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\t\tif (refVal && self[refVal] instanceof Node) {\n\t\t\t\t\tdelete self[refVal];\n\t\t\t\t}\n\t\t\t\tif (handlerMap.has(node)) {\n\t\t\t\t\tremoveAllHandlers(node, self);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Step 3: Render/Update UI\n\t\tvar frag = parseAsFragment(self.toString());\n\t\tvar els = from(frag.childNodes)\n\t\t// var el = frag.firstElementChild;\n\n\t\t// Update existing DOM.\n\t\tif (target) {\n\t\t\tpatchDom(target, els);\n\t\t}\n\n\t\t// Step 4: Re-focus\n\t\tif (focusId) {\n\t\t\tvar focusEl = document.getElementById(focusId);\n\t\t\tif (focusEl) {\n\t\t\t\tfocusEl.focus();\n\t\t\t}\n\t\t}\n\n\t\tself.domHydrate();\n\t},\n\n\t/**\n\t * @private\n\t */\n\tdomHydrate() {\n\t\t// Doing step 5 and 6 from render() function\n\t\t// Step 5: Resolve refs\n\t\t// Step 6: Attach event listeners\n\n\t\tvar self = this;\n\t\t// TODO: only set this on debug mode\n\t\tself.el.pepperInstance = self;\n\n\t\t// Note: ref creates a reference to the node as property on the view.\n\t\ttraverseElements(self.el, (node) => {\n\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\tif (refVal) {\n\t\t\t\tself[refVal] = node;\n\t\t\t}\n\t\t\teach(node.attributes, (attr) => {\n\t\t\t\tif (attr.name.startsWith('on-')) {\n\t\t\t\t\tvar eventName = attr.name.replace(/on-/, '');\n\t\t\t\t\tattachHandler(node, self, eventName, self[attr.value]);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * @param {Boolean} [hydrateOnly=false] does a full render by default. 'Hydration' only\n\t * attaches event listeners and resolves refs.\n\t * @returns \n\t */\n\tmount(hydrateOnly = false) {\n\t\tvar self = this;\n\t\tvar stores = self.stores;\n\t\tif (stores) {\n\t\t\tkeys(stores).forEach((storeKey) => {\n\t\t\t\tconst { store, props } = stores[storeKey];\n\t\t\t\tstore.subscribe(props, self.render, self);\n\t\t\t});\n\t\t}\n\n\t\tvar node = self.target;\n\t\tif (typeof node === 'string') {\n\t\t\tnode = document.querySelector(node);\n\t\t}\n\n\t\t// Return if already mounted.\n\t\tif (self.el && node === self.el) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node) {\n\t\t\tself.el = node;\n\t\t\tif (hydrateOnly) {\n\t\t\t\tself.domHydrate();\n\t\t\t} else { // full render\n\t\t\t\tself.render();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\thydrate(data) {\n\t\tif (arguments.length > 0 && data && typeof data === 'object') {\n\t\t\tthis._data = data;\n\t\t}\n\t\tthis.mount(true);\n\t},\n\n\tunmount() {\n\t\tvar self = this;\n\t\tvar stores = self.stores;\n\t\tif (stores) {\n\t\t\tkeys(stores).forEach((storeKey) => {\n\t\t\t\tstores[storeKey].store.unsubscribe(self.render, self);\n\t\t\t});\n\t\t}\n\t\tself.el.replaceChildren(); // empty replaceChildren removes all child elements\n\t}\n};\n\nexport { Pepper, Store, html };\n", "var from = Array.from;\n\nfunction each(arrayLike, fn) {\n\treturn Array.prototype.forEach.call(arrayLike, fn);\n}\n\nfunction isCustomElement(element) {\n\tif (element.tagName.indexOf('-') > 0) return true;\n\tvar attr = element.getAttribute('is');\n\treturn (attr && attr.indexOf('-') > 0);\n}\n\nfunction keys(obj) {\n  if (!obj) return [];\n\treturn Object.keys(obj).filter(key => key !== 'constructor');\n}\n// Safer Object.assign\nfunction objectAssign(target) {\n\tfrom(arguments).forEach((obj, index) => {\n\t\tif (!index) return;\n\t\tkeys(obj).forEach((key) => {\n\t\t\ttarget[key] = obj[key];\n\t\t});\n\t});\n\treturn target;\n}\n\nexport {\n  each,\n  isCustomElement,\n  from,\n  keys,\n  objectAssign,\n};", "import { each, isCustomElement } from './utils.js';\n\n// This implementation is faster than Array.from(el.childNodes)\nfunction getChildNodes(el) {\n  var l = [];\n  for (var node = el.firstChild; node; node = node.nextSibling) {\n    l.push(node);\n  }\n  return l;\n}\n\n/**\n * @param {Element} newNode\n * @param {Element} liveNode\n */\nfunction syncNode(newNode, liveNode) {\n  // Remove any attributes from live node that is not in new node\n\teach(liveNode.attributes, (attr) => {\n\t\tif (!newNode.attributes.getNamedItem(attr.name)) {\n\t\t\tliveNode.attributes.removeNamedItem(attr.name);\n\t\t}\n\t});\n\n\t// update the rest\n\teach(newNode.attributes, (attr) => {\n\t\tif (liveNode.getAttribute(attr.name) !== attr.value) {\n\t\t\tliveNode.setAttribute(attr.name, attr.value);\n\t\t}\n\t});\n\n  // recursively sync children if innerHTML is different, except\n  // custom elements (because encapsulation. reactivity with CE is via attributes only)\n  if (!isCustomElement(newNode) && newNode.innerHTML != liveNode.innerHTML) {\n    patchDom(\n      liveNode,\n      getChildNodes(newNode),\n    );\n  }\n}\n\nfunction getCustomElementOuterHtml(el) {\n\treturn el.outerHTML.slice(0, -(el.innerHTML.length + el.tagName.length + 4)) + '/>';\n}\n\n/**\n * @param {Node} node\n * @returns {string}\n */\nfunction hashNode(node) {\n\treturn node.nodeType + ':' + (\n    (node.nodeType === 1 ?\n      (\n        isCustomElement(node) ?\n        getCustomElementOuterHtml(node) :\n        /** @type {Element} */ (node).outerHTML\n      ) :\n      // comment, text, cdata node\n      node.nodeValue\n    )\n  );\n}\n\n/**\n * @param {Node[]} a live nodes\n * @param {number} aStart \n * @param {number} aEnd \n * @param {Node[]} b new nodes\n * @param {number} bStart \n * @param {number} bEnd\n * @returns \n */\nfunction matchNodes(a, aStart, aEnd, b, bStart, bEnd) {\n  /**\n   * Group elements with same hash\n   * @type {Record<string, Node[]>}\n   */\n  var domLookup = {};\n  /** @type {Map<Node, Node>} */\n  var newNodeToLiveNodeMatch = new Map(); // 'n' (new) node to 'l' (live) node map\n \n  var i, hash;\n  for (i = bStart; i < bEnd; i++) {\n    hash = hashNode(b[i]);\n    if (!domLookup[hash]) domLookup[hash] = [];\n    domLookup[hash].push(b[i]);\n  }\n  \n  /**\n   * For unmatched elements, we later want to re-use them if we can\n   * @type {Record<string, Element[]>}\n   */\n  var salvagableElements = {};\n  var salvagableElementsById = {};\n  var newNode;\n  for (i = aStart; i < aEnd; i++) {\n    var liveNode = a[i];\n    hash = hashNode(liveNode);\n    var entry = domLookup[hash];\n    var matched = false;\n    if (entry) {\n      newNode = entry.shift(); // pick first match\n      if (newNode) {\n        newNodeToLiveNodeMatch.set(newNode, liveNode);\n        matched = true;\n      }\n    }\n    if (!matched && liveNode.nodeType === 1) {\n      if (liveNode.id) salvagableElementsById[liveNode.id] = liveNode;\n      if (!salvagableElements[liveNode.nodeName]) salvagableElements[liveNode.nodeName] = [];\n      salvagableElements[liveNode.nodeName].push(/** @type {Element} */ (liveNode));\n    }\n  }\n\n  var aLiveNode;\n  // match by id to reuse existing elements which gives a better\n  // chance to preserve DOM states like input focus.\n  for (i = bStart; i < bEnd; i++) {\n    newNode = b[i];\n    if (newNodeToLiveNodeMatch.get(newNode)) continue;\n\n    var id = newNode.id;\n    aLiveNode = id && salvagableElementsById[id];\n    if (aLiveNode) {\n      syncNode(newNode, aLiveNode);\n      newNodeToLiveNodeMatch.set(newNode, aLiveNode);\n      salvagableElements[newNode.nodeName].splice(\n        salvagableElements[newNode.nodeName].indexOf(aLiveNode), \n        1,\n      )\n      salvagableElementsById[id] = null;\n    }\n  }\n\n  // match by tag name to reuse existing elements which gives a better\n  // chance to preserve DOM states like input focus.\n  for (i = bStart; i < bEnd; i++) {\n    newNode = b[i];\n    if (newNodeToLiveNodeMatch.get(newNode)) continue;\n\n    if (newNode.nodeType === 1 && (aLiveNode = (salvagableElements[newNode.nodeName] || []).shift())) {\n      syncNode(newNode, aLiveNode);\n      newNodeToLiveNodeMatch.set(newNode, aLiveNode);\n    }\n  }\n\n  return newNodeToLiveNodeMatch;\n}\n\n/**\n * @param {Element} parentNode\n * @param {Node[]} newNodes\n */\nfunction patchDom(parentNode, newNodes) {\n  var a = getChildNodes(parentNode);\n  var aLen = a.length;\n  var aStart = 0;\n  var aEnd = aLen;\n  var b = newNodes;\n  var bStart = 0;\n  var bEnd = b.length;\n\n  // Thanks to https://github.com/WebReflection/udomdiff for the fast path inspiration.\n  while (aStart < aEnd || bStart < bEnd) {\n    // fast path to append head or tail\n    if (aEnd === aStart) {\n      var insertBefore = a[aEnd];\n      while (bStart < bEnd) {\n        parentNode.insertBefore(b[bStart++], insertBefore);\n      }\n    } // fast path to remove head or tail \n    else if (bEnd === bStart) {\n      // fast path to remove all nodes\n      if (!b.length) {\n        parentNode.replaceChildren();\n        aEnd = aStart;\n      } else {\n        while (aStart < aEnd) {\n          a[--aEnd].remove();\n        }\n      }\n    } // fast path for same head \n    else if (a[aStart].isEqualNode(b[bStart])) {\n      aStart++;\n      bStart++;\n    } // fast path for same tail\n    else if (a[aEnd - 1].isEqualNode(b[bEnd - 1])) {\n      aEnd--;\n      bEnd--;\n    } // fast path for swaps \n    else if (\n      aStart < (aEnd - 1)\n      && bStart < (bEnd - 1)\n      && a[aStart].isEqualNode(b[bEnd - 1])\n      && b[bStart].isEqualNode(a[aEnd - 1])\n    ) {\n      // swap operation that could happen also in this case:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      --aEnd;\n      bStart++;\n      --bEnd;\n      var oldStartNode = a[aStart++];\n      var oldEndNode = a[aEnd];\n      var startInsertBefore = oldStartNode.nextSibling;\n      parentNode.insertBefore(oldStartNode, oldEndNode.nextSibling);\n      // if the two nodes were adjacent siblings then they are already swapped now, so ignore that case.\n      if (startInsertBefore !== oldEndNode) {\n        parentNode.insertBefore(oldEndNode, startInsertBefore);\n      }\n    } // diff, \"slow\" path\n    else {\n      var newNodeToLiveNodeMatch = matchNodes(a, aStart, aEnd, b, bStart, bEnd);\n    \n      // insert the future nodes into position\n      var i, newNode, nodeAtPosition;\n      for (i = bStart; i < bEnd; i++) {\n        newNode = b[i];\n        // check for exact match live node\n        var existingLiveNode = newNodeToLiveNodeMatch.get(newNode);\n        nodeAtPosition = nodeAtPosition ? nodeAtPosition.nextSibling : a[i];\n        if (existingLiveNode) {\n          // place it at the position. If nodeAtPosition is undefined, then inserts to end\n          if (nodeAtPosition !== existingLiveNode) {\n            parentNode.insertBefore(existingLiveNode, nodeAtPosition);\n            nodeAtPosition = existingLiveNode;\n          }\n          // else nothing to do if exact match is already at the right position\n        } else {\n          // At this point the node is either a text node, comment node or\n          // an element that cant re-use another element.\n          parentNode.insertBefore(newNode, nodeAtPosition);\n          nodeAtPosition = newNode;\n          aLen++; // keep track of actual child nodes length (to be used in removal loop later)\n        }\n      }\n    \n      // now if live nodes length > new nodes length, keep discarding node\n      // from bEnd position (newNode.nextSibling)\n      while (aLen-- > b.length) {\n        nodeAtPosition.nextSibling.remove();\n      }\n      break;\n    }\n  }\n}\n\nexport { patchDom };", "import { keys, objectAssign } from './utils.js'\n\n// A store for Pepper views\n// it only does a shallow (i.e level 1) equality check of the store data properties\n// for notifying relevant connected views to re-render\n/**\n * @constructor\n * @param {Object} initialData\n */\nfunction Store(initialData) {\n\tvar self = this;\n\t/** @private */\n\tself._data = initialData || {};\n\t/** @private */\n\tself._subscribers = [];\n\n\tObject.defineProperty(this, 'data', {\n\t\tconfigurable: false,\n\t\tset(newData) {\n\t\t\tif (typeof newData !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar changedProps = [].concat(\n\t\t\t\t// find props that were changed\n\t\t\t\tkeys(newData).filter((prop) => self._data[prop] !== newData[prop]),\n\t\t\t\t// find props that got removed (i.e. not in new data)\n\t\t\t\tkeys(self._data).filter((prop) => !(prop in newData))\n\t\t\t);\n\t\t\tself._data = newData;\n\t\t\tself.notify(changedProps);\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n}\n\nStore.prototype = {\n\t/**\n\t * Reactive data - Getter/Setter\n\t */\n\tdata: {},\n\t/**\n\t * @private\n\t */\n\tnotify(changedProps) {\n\t\tvar changedPropsLookup = changedProps.reduce((acc, prop) => {\n\t\t\tacc[prop] = 1;\n\t\t\treturn acc;\n\t\t}, {});\n\t\tthis._subscribers.forEach((subscriber) => {\n\t\t\tvar changesPropsSubset = subscriber.props.filter((prop) => changedPropsLookup[prop]);\n\t\t\tif (changesPropsSubset.length) {\n\t\t\t\tsubscriber.callback.call(subscriber.context, changesPropsSubset);\n\t\t\t}\n\t\t});\n\t},\n\t/**\n\t * Subscribe to changes in global store properties\n\t * @param {string[]} propsToListenFor\n\t * @param {() => undefined} func\n\t * @param {any} [context]\n\t * @returns \n\t */\n\tsubscribe(propsToListenFor, func, context) {\n\t\tif (typeof func !== 'function' || !Array.isArray(propsToListenFor)) {\n\t\t\treturn;\n\t\t}\n\t\tvar self = this;\n\t\tvar alreadyAdded = self._subscribers.some((subscriber) => (\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t\tif (!alreadyAdded) {\n\t\t\tself._subscribers.push({\n\t\t\t\tprops: propsToListenFor,\n\t\t\t\tcallback: func,\n\t\t\t\tcontext: context\n\t\t\t});\n\t\t}\n\t},\n\tunsubscribe(func, context) {\n\t\tthis._subscribers = this._subscribers.filter((subscriber) => !(\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t},\n\tassign(newData) {\n\t\tvar self = this;\n\t\tif (typeof newData !== 'object') {\n\t\t\treturn;\n\t\t}\n\t\tvar changedProps = keys(newData).filter((prop) => self._data[prop] !== newData[prop]);\n\t\tobjectAssign(self._data, newData);\n\t\tself.notify(changedProps);\n\t}\n};\n\nexport { Store };", "const characterEntitiesMapping = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '&': '&amp;',\n  \"'\": '&apos;',\n  '\"': '&quot;',\n};\nfunction escape(text) {\n  if (!text) return text;\n  return text.replace(/[<>&'\"]/g, character => characterEntitiesMapping[character]);\n}\n// Utility for users not using a template library\nfunction html(strings, ...values) {\n  return strings.reduce((acc, string, index) => {\n    let value = String(values[index - 1]);\n    if ((strings[index - 1] || '').endsWith(\"$\")) {\n      // If $ sign precedes the interpolation, then its considered safe to\n      // add the unescaped / raw HTML\n      acc = acc.slice(0, -1);\n    } else {\n      value = escape(value);\n    }\n    return acc + value + string;\n  });\n}\n\nexport { html };"],
  "mappings": "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",
  "names": ["keys", "html", "storeData"]
}
