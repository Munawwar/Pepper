{
  "version": 3,
  "sources": ["../../../src/index.js", "../../../src/utils.js", "../../../src/dom-diff.js", "../../../src/store.js", "../../../src/html.js"],
  "sourcesContent": ["// utils\nimport {\n\tfrom,\n\tobjectAssign,\n\teach,\n\tisCustomElement,\n\tkeys\n} from './utils.js';\nimport { patchDom } from './dom-diff.js';\nimport { Store } from './store.js';\nimport { html } from './html.js';\n\n// Deep merge helper\nfunction merge(out) {\n\tout = out || {};\n\tfor (var argIndex = 1; argIndex < arguments.length; argIndex++) {\n\t\tvar obj = arguments[argIndex];\n\t\tif (!obj || typeof val !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\t\tvar keys = keys(obj);\n\t\tfor (var keyIndex = 1; keyIndex < keys.length; keyIndex++) {\n\t\t\tvar key = keys[keyIndex];\n\t\t\tvar val = obj[key];\n\t\t\tout[key] = (typeof val === 'object' && val !== null)\n\t\t\t\t? merge(out[key], val)\n\t\t\t\t: val;\n\t\t}\n\t}\n\treturn out;\n}\n/**\n * Converts html string to a document fragment.\n * @param {String} html\n * @return {DocumentFragment}\n * @method dom\n */\nfunction parseAsFragment(html) {\n\tvar templateTag = document.createElement('template');\n\ttemplateTag.innerHTML = html;\n\treturn templateTag.content;\n}\n\n/**\n * Traverse elements of a tree in order of visibility (pre-order traversal)\n * @param {Node} parentNode\n * @param {(Node) => void} onNextNode\n */\nfunction traverseElements(parentNode, onNextNode) {\n\tvar treeWalker = document.createTreeWalker(parentNode, NodeFilter.SHOW_ELEMENT),\n\t\t\tnode = treeWalker.nextNode();\n\twhile (node) {\n\t\t// dont touch the inner nodes of custom elements\n\t\tif (isCustomElement(node)) {\n\t\t\tnode = treeWalker.nextSibling();\n\t\t\tcontinue;\n\t\t}\n\t\tonNextNode(node);\n\t\tnode = treeWalker.nextNode();\n\t}\n}\n\n/**\n * @template DataType\n * @param {Object} config \n * @param {HTMLElement} config.target\n * @param {DataType} config.data\n * @param {(data: DataType) => String} config.getHtml\n * @param {Boolean} [config.mount=false]\n * @param {Boolean} [config.hydrate=false]\n * @param {{ [storeKey: string]: { store: Store, props: String[] } }|null} [config.stores]\n */\nfunction Pepper(config) {\n\tvar self = this;\n\tself._data = (typeof config.data === 'object' && config.data) || {};\n\tvar mount = config.mount;\n\tvar hydrate = config.hydrate;\n\t\n\tdelete config.data;\n\tdelete config.mount;\n\tdelete config.hydrate;\n\tobjectAssign(self, config);\n\tObject.defineProperty(self, 'data', {\n\t\tconfigurable: false,\n\t\tset(data) {\n\t\t\tself._data = data;\n\t\t\t// TODO: only render if there is a change\n\t\t\tself.render();\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n\tif (hydrate) {\n\t\tself.hydrate()\n\t} else if (mount) {\n\t\tself.mount();\n\t}\n}\n\n// private\nvar handlerMap = new WeakMap();\n/**\n * Helper to attach handleEvent object event listener to element.\n * @param {HTMLElement} node\n * @param {Object} context\n * @param {String} eventName\n * @param {Function} func\n */\nfunction attachHandler(node, context, eventName, func) {\n\tif (!func) return;\n\tvar newMap = handlerMap.get(node) || {};\n\tnewMap[eventName] = func;\n\thandlerMap.set(node, newMap);\n\tnode.addEventListener(eventName, context);\n}\n/**\n * Removes all event handlers on node. Ensure same context is passed as it\n * was for attachHandler() function, else the event listeners wont get removed.\n */\nfunction removeAllHandlers(node, context) {\n\tObject.keys(handlerMap.get(node) || {}).forEach((eventName) => {\n\t\tnode.removeEventListener(eventName, context);\n\t});\n\thandlerMap.delete(node);\n}\n/**\n * Invokes an event handler that was registered via attachHandler\n * @param {Pepper} context \n * @param {Event} event \n */\nfunction callHandler(context, event) {\n\tvar node = event.currentTarget;\n\tvar func = (handlerMap.get(node) || {})[event.type];\n\tif (func) {\n\t\tfunc.call(context, event);\n\t}\n}\n\n// Methods and properties\nPepper.prototype = {\n\t/**\n\t * The data object.\n\t * This is a private variable accessed through this.data\n\t * setter/getter.\n\t */\n\t_data: null,\n\n\t/**\n\t * (Optional) The element to replace (on first render).\n\t */\n\ttarget: null,\n\n\t/**\n\t * (Optional) A Pepper store and array of props to listen to. The properties will be added to\n\t * `data.stores` passed to this.getHtml() function.\n\t * This instance will re-render (when mounted) when the specified props change in the store\n\t * Example: ['cart', 'wishlist']\n\t * @type {{\n\t * \t[storeKey: string]: {\n\t * \t  store: Store,\n\t *    props: string[]\n\t *  }\n\t * }|null}\n\t */\n\tstores: null,\n\n\t/**\n\t * Function that returns component's html to be rendered\n\t * @param {any} data combined data from this.data and subscribed stores\n\t * @returns {string}\n\t */\n\tgetHtml() { return ''; },\n\t\n\t/**\n\t * Set data on this.data (using Object.assign), and re-render.\n\t */\n\tassign() {\n\t\tvar args = from(arguments);\n\t\tobjectAssign.apply(null, [this.data].concat(args));\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\t/**\n\t * Deep merge data with this.data, and re-render.\n\t */\n\tmerge(data) {\n\t\tmerge(this.data, data);\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\thandleEvent(event) {\n\t\tcallHandler(this, event);\n\t},\n\n\ttoString: function renderToString() {\n\t\tvar self = this;\n\t\tvar stores = self.stores;\n\t\tconst storeData = keys(stores).reduce((acc, storeKey) => {\n\t\t\tvar { store, props } = stores[storeKey];\n\t\t\tvar storeData = (store && store._data) || {};\n\t\t\tacc[storeKey] = (props || []).reduce((acc2, prop) => {\n\t\t\t\tacc2[prop] = storeData[prop];\n\t\t\t\treturn acc2;\n\t\t\t}, {});\n\t\t\treturn acc;\n\t\t}, {});\n\t\tvar data = objectAssign({ stores: storeData }, self.data);\n\t\treturn self.getHtml(data);\n\t},\n\n\t/**\n\t * Render view.\n\t * If this.target or node parameter is specified, then replaces that node and attaches the\n\t * rendered DOM to document (or document fragment).\n\t *\n\t * @private\n\t */\n\trender() {\n\t\t// Step 1: Remove event listeners and refs\n\t\t// Step 2: Note the currently focused element\n\t\t// Step 3: Render/Update UI.\n\t\t// Step 4: Resolve references\n\t\t// Step 5: Re-focus\n\t\t// Step 6: Re-attach listeners\n\t\t\n\t\tvar self = this;\n\t\tvar target = self.el;\n\n\t\t// Step 1: Find input field focus, remember it's id attribute, so that it\n\t\t// can be refocused later.\n\t\tvar focusId = document.activeElement.id;\n\n\t\t// Step 2: Remove event listeners and refs before patch.\n\t\tif (target) {\n\t\t\ttraverseElements(target, (node) => {\n\t\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\t\tif (refVal && self[refVal] instanceof Node) {\n\t\t\t\t\tdelete self[refVal];\n\t\t\t\t}\n\t\t\t\tif (handlerMap.has(node)) {\n\t\t\t\t\tremoveAllHandlers(node, self);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Step 3: Render/Update UI\n\t\tvar frag = parseAsFragment(self.toString());\n\t\tvar els = from(frag.childNodes)\n\t\t// var el = frag.firstElementChild;\n\n\t\t// Update existing DOM.\n\t\tif (target) {\n\t\t\tpatchDom(target, els);\n\t\t}\n\n\t\t// Step 4: Re-focus\n\t\tif (focusId) {\n\t\t\tvar focusEl = document.getElementById(focusId);\n\t\t\tif (focusEl) {\n\t\t\t\tfocusEl.focus();\n\t\t\t}\n\t\t}\n\n\t\tself.domHydrate();\n\t},\n\n\t/**\n\t * @private\n\t */\n\tdomHydrate() {\n\t\t// Doing step 5 and 6 from render() function\n\t\t// Step 5: Resolve refs\n\t\t// Step 6: Attach event listeners\n\n\t\tvar self = this;\n\t\t// TODO: only set this on debug mode\n\t\tself.el.pepperInstance = self;\n\n\t\t// Note: ref creates a reference to the node as property on the view.\n\t\ttraverseElements(self.el, (node) => {\n\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\tif (refVal) {\n\t\t\t\tself[refVal] = node;\n\t\t\t}\n\t\t\teach(node.attributes, (attr) => {\n\t\t\t\tif (attr.name.startsWith('on-')) {\n\t\t\t\t\tvar eventName = attr.name.replace(/on-/, '');\n\t\t\t\t\tattachHandler(node, self, eventName, self[attr.value]);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * @param {Boolean} [hydrateOnly=false] does a full render by default. 'Hydration' only\n\t * attaches event listeners and resolves refs.\n\t * @returns \n\t */\n\tmount(hydrateOnly = false) {\n\t\tvar self = this;\n\t\tvar stores = self.stores;\n\t\tif (stores) {\n\t\t\tkeys(stores).forEach((storeKey) => {\n\t\t\t\tconst { store, props } = stores[storeKey];\n\t\t\t\tstore.subscribe(props, self.render, self);\n\t\t\t});\n\t\t}\n\n\t\tvar node = self.target;\n\t\tif (typeof node === 'string') {\n\t\t\tnode = document.querySelector(node);\n\t\t}\n\n\t\t// Return if already mounted.\n\t\tif (self.el && node === self.el) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node) {\n\t\t\tself.el = node;\n\t\t\tif (hydrateOnly) {\n\t\t\t\tself.domHydrate();\n\t\t\t} else { // full render\n\t\t\t\tself.render();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\thydrate(data) {\n\t\tif (arguments.length > 0 && data && typeof data === 'object') {\n\t\t\tthis._data = data;\n\t\t}\n\t\tthis.mount(true);\n\t},\n\n\tunmount() {\n\t\tvar self = this;\n\t\tvar stores = self.stores;\n\t\tif (stores) {\n\t\t\tkeys(stores).forEach((storeKey) => {\n\t\t\t\tstores[storeKey].store.unsubscribe(self.render, self);\n\t\t\t});\n\t\t}\n\t\tself.el.replaceChildren(); // empty replaceChildren removes all child elements\n\t}\n};\n\nexport { Pepper, Store, html };\n", "var from = Array.from;\n\nfunction each(arrayLike, fn) {\n\treturn Array.prototype.forEach.call(arrayLike, fn);\n}\n\nfunction isCustomElement(element) {\n\tif (element.tagName.indexOf('-') > 0) return true;\n\tvar attr = element.getAttribute('is');\n\treturn (attr && attr.indexOf('-') > 0);\n}\n\nfunction keys(obj) {\n  if (!obj) return [];\n\treturn Object.keys(obj).filter(key => key !== 'constructor');\n}\n// Safer Object.assign\nfunction objectAssign(target) {\n\tfrom(arguments).forEach((obj, index) => {\n\t\tif (!index) return;\n\t\tkeys(obj).forEach((key) => {\n\t\t\ttarget[key] = obj[key];\n\t\t});\n\t});\n\treturn target;\n}\n\nexport {\n  each,\n  isCustomElement,\n  from,\n  keys,\n  objectAssign,\n};", "import { each, isCustomElement } from './utils.js';\n\n// This implementation is faster than Array.from(el.childNodes)\nfunction getChildNodes(el) {\n  var l = [];\n  for (var node = el.firstChild; node; node = node.nextSibling) {\n    l.push(node);\n  }\n  return l;\n}\n\n/**\n * @param {Element} newNode\n * @param {Element} liveNode\n */\nfunction syncNode(newNode, liveNode) {\n  // Remove any attributes from live node that is not in new node\n\teach(liveNode.attributes, (attr) => {\n\t\tif (!newNode.attributes.getNamedItem(attr.name)) {\n\t\t\tliveNode.attributes.removeNamedItem(attr.name);\n\t\t}\n\t});\n\n\t// update the rest\n\teach(newNode.attributes, (attr) => {\n\t\tif (liveNode.getAttribute(attr.name) !== attr.value) {\n\t\t\tliveNode.setAttribute(attr.name, attr.value);\n\t\t}\n\t});\n\n  // recursively sync children if innerHTML is different, except\n  // custom elements (because encapsulation. reactivity with CE is via attributes only)\n  if (!isCustomElement(newNode) && newNode.innerHTML != liveNode.innerHTML) {\n    patchDom(\n      liveNode,\n      getChildNodes(newNode),\n    );\n  }\n}\n\nfunction getCustomElementOuterHtml(el) {\n\treturn el.outerHTML.slice(0, -(el.innerHTML.length + el.tagName.length + 4)) + '/>';\n}\n\n/**\n * @param {Node} node\n * @returns {string}\n */\nfunction hashNode(node) {\n\treturn node.nodeType + ':' + (\n    (node.nodeType === 1 ?\n      (\n        isCustomElement(node) ?\n        getCustomElementOuterHtml(node) :\n        /** @type {Element} */ (node).outerHTML\n      ) :\n      // comment, text, cdata node\n      node.nodeValue\n    )\n  );\n}\n\n/**\n * @param {Node[]} a live nodes\n * @param {number} aStart \n * @param {number} aEnd \n * @param {Node[]} b new nodes\n * @param {number} bStart \n * @param {number} bEnd\n * @returns \n */\nfunction matchNodes(a, aStart, aEnd, b, bStart, bEnd) {\n  /**\n   * Group elements with same hash\n   * @type {Record<string, Node[]>}\n   */\n  var domLookup = {};\n  /** @type {Map<Node, Node>} */\n  var newNodeToLiveNodeMatch = new Map(); // 'n' (new) node to 'l' (live) node map\n \n  var i, hash;\n  for (i = bStart; i < bEnd; i++) {\n    hash = hashNode(b[i]);\n    if (!domLookup[hash]) domLookup[hash] = [];\n    domLookup[hash].push(b[i]);\n  }\n  \n  /**\n   * For unmatched elements, we later want to re-use them if we can\n   * @type {Record<string, Element[]>}\n   */\n  var salvagableElements = {};\n  var salvagableElementsById = {};\n  var newNode;\n  for (i = aStart; i < aEnd; i++) {\n    var liveNode = a[i];\n    hash = hashNode(liveNode);\n    var entry = domLookup[hash];\n    var matched = false;\n    if (entry) {\n      newNode = entry.shift(); // pick first match\n      if (newNode) {\n        newNodeToLiveNodeMatch.set(newNode, liveNode);\n        matched = true;\n      }\n    }\n    if (!matched && liveNode.nodeType === 1) {\n      if (liveNode.id) salvagableElementsById[liveNode.id] = liveNode;\n      if (!salvagableElements[liveNode.nodeName]) salvagableElements[liveNode.nodeName] = [];\n      salvagableElements[liveNode.nodeName].push(/** @type {Element} */ (liveNode));\n    }\n  }\n\n  var aLiveNode;\n  // match by id to reuse existing elements which gives a better\n  // chance to preserve DOM states like input focus.\n  for (i = bStart; i < bEnd; i++) {\n    newNode = b[i];\n    if (newNodeToLiveNodeMatch.get(newNode)) continue;\n\n    var id = newNode.id;\n    aLiveNode = id && salvagableElementsById[id];\n    if (aLiveNode) {\n      syncNode(newNode, aLiveNode);\n      newNodeToLiveNodeMatch.set(newNode, aLiveNode);\n      salvagableElements[newNode.nodeName].splice(\n        salvagableElements[newNode.nodeName].indexOf(aLiveNode), \n        1,\n      )\n      salvagableElementsById[id] = null;\n    }\n  }\n\n  // match by tag name to reuse existing elements which gives a better\n  // chance to preserve DOM states like input focus.\n  for (i = bStart; i < bEnd; i++) {\n    newNode = b[i];\n    if (newNodeToLiveNodeMatch.get(newNode)) continue;\n\n    if (newNode.nodeType === 1 && (aLiveNode = (salvagableElements[newNode.nodeName] || []).shift())) {\n      syncNode(newNode, aLiveNode);\n      newNodeToLiveNodeMatch.set(newNode, aLiveNode);\n    }\n  }\n\n  return newNodeToLiveNodeMatch;\n}\n\n/**\n * @param {Element} parentNode\n * @param {Node[]} newNodes\n */\nfunction patchDom(parentNode, newNodes) {\n  var a = getChildNodes(parentNode);\n  var aLen = a.length;\n  var aStart = 0;\n  var aEnd = aLen;\n  var b = newNodes;\n  var bStart = 0;\n  var bEnd = b.length;\n\n  // Thanks to https://github.com/WebReflection/udomdiff for the fast path inspiration.\n  while (aStart < aEnd || bStart < bEnd) {\n    // fast path to append head or tail\n    if (aEnd === aStart) {\n      var insertBefore = a[aEnd];\n      while (bStart < bEnd) {\n        parentNode.insertBefore(b[bStart++], insertBefore);\n      }\n    } // fast path to remove head or tail \n    else if (bEnd === bStart) {\n      // fast path to remove all nodes\n      if (!b.length) {\n        parentNode.replaceChildren();\n        aEnd = aStart;\n      } else {\n        while (aStart < aEnd) {\n          a[--aEnd].remove();\n        }\n      }\n    } // fast path for same head \n    else if (a[aStart].isEqualNode(b[bStart])) {\n      aStart++;\n      bStart++;\n    } // fast path for same tail\n    else if (a[aEnd - 1].isEqualNode(b[bEnd - 1])) {\n      aEnd--;\n      bEnd--;\n    } // fast path for swaps \n    else if (\n      aStart < (aEnd - 1)\n      && bStart < (bEnd - 1)\n      && a[aStart].isEqualNode(b[bEnd - 1])\n      && b[bStart].isEqualNode(a[aEnd - 1])\n    ) {\n      // swap operation that could happen also in this case:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      --aEnd;\n      bStart++;\n      --bEnd;\n      var oldStartNode = a[aStart++];\n      var oldEndNode = a[aEnd];\n      var startInsertBefore = oldStartNode.nextSibling;\n      parentNode.insertBefore(oldStartNode, oldEndNode.nextSibling);\n      // if the two nodes were adjacent siblings then they are already swapped now, so ignore that case.\n      if (startInsertBefore !== oldEndNode) {\n        parentNode.insertBefore(oldEndNode, startInsertBefore);\n      }\n    } // diff, \"slow\" path\n    else {\n      var newNodeToLiveNodeMatch = matchNodes(a, aStart, aEnd, b, bStart, bEnd);\n    \n      // insert the future nodes into position\n      var i, newNode, nodeAtPosition;\n      for (i = bStart; i < bEnd; i++) {\n        newNode = b[i];\n        // check for exact match live node\n        var existingLiveNode = newNodeToLiveNodeMatch.get(newNode);\n        nodeAtPosition = nodeAtPosition ? nodeAtPosition.nextSibling : a[i];\n        if (existingLiveNode) {\n          // place it at the position. If nodeAtPosition is undefined, then inserts to end\n          if (nodeAtPosition !== existingLiveNode) {\n            parentNode.insertBefore(existingLiveNode, nodeAtPosition);\n            nodeAtPosition = existingLiveNode;\n          }\n          // else nothing to do if exact match is already at the right position\n        } else {\n          // At this point the node is either a text node, comment node or\n          // an element that cant re-use another element.\n          parentNode.insertBefore(newNode, nodeAtPosition);\n          nodeAtPosition = newNode;\n          aLen++; // keep track of actual child nodes length (to be used in removal loop later)\n        }\n      }\n    \n      // now if live nodes length > new nodes length, keep discarding node\n      // from bEnd position (newNode.nextSibling)\n      while (aLen-- > b.length) {\n        nodeAtPosition.nextSibling.remove();\n      }\n      break;\n    }\n  }\n}\n\nexport { patchDom };", "import { keys, objectAssign } from './utils.js'\n\n// A store for Pepper views\n// it only does a shallow (i.e level 1) equality check of the store data properties\n// for notifying relevant connected views to re-render\n/**\n * @constructor\n * @param {Object} initialData\n */\nfunction Store(initialData) {\n\tvar self = this;\n\t/** @private */\n\tself._data = initialData || {};\n\t/** @private */\n\tself._subscribers = [];\n\n\tObject.defineProperty(this, 'data', {\n\t\tconfigurable: false,\n\t\tset(newData) {\n\t\t\tif (typeof newData !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar changedProps = [].concat(\n\t\t\t\t// find props that were changed\n\t\t\t\tkeys(newData).filter((prop) => self._data[prop] !== newData[prop]),\n\t\t\t\t// find props that got removed (i.e. not in new data)\n\t\t\t\tkeys(self._data).filter((prop) => !(prop in newData))\n\t\t\t);\n\t\t\tself._data = newData;\n\t\t\tself.notify(changedProps);\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n}\n\nStore.prototype = {\n\t/**\n\t * Reactive data - Getter/Setter\n\t */\n\tdata: {},\n\t/**\n\t * @private\n\t */\n\tnotify(changedProps) {\n\t\tvar changedPropsLookup = changedProps.reduce((acc, prop) => {\n\t\t\tacc[prop] = 1;\n\t\t\treturn acc;\n\t\t}, {});\n\t\tthis._subscribers.forEach((subscriber) => {\n\t\t\tvar changesPropsSubset = subscriber.props.filter((prop) => changedPropsLookup[prop]);\n\t\t\tif (changesPropsSubset.length) {\n\t\t\t\tsubscriber.callback.call(subscriber.context, changesPropsSubset);\n\t\t\t}\n\t\t});\n\t},\n\t/**\n\t * Subscribe to changes in global store properties\n\t * @param {string[]} propsToListenFor\n\t * @param {() => undefined} func\n\t * @param {any} [context]\n\t * @returns \n\t */\n\tsubscribe(propsToListenFor, func, context) {\n\t\tif (typeof func !== 'function' || !Array.isArray(propsToListenFor)) {\n\t\t\treturn;\n\t\t}\n\t\tvar self = this;\n\t\tvar alreadyAdded = self._subscribers.some((subscriber) => (\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t\tif (!alreadyAdded) {\n\t\t\tself._subscribers.push({\n\t\t\t\tprops: propsToListenFor,\n\t\t\t\tcallback: func,\n\t\t\t\tcontext: context\n\t\t\t});\n\t\t}\n\t},\n\tunsubscribe(func, context) {\n\t\tthis._subscribers = this._subscribers.filter((subscriber) => !(\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t},\n\tassign(newData) {\n\t\tvar self = this;\n\t\tif (typeof newData !== 'object') {\n\t\t\treturn;\n\t\t}\n\t\tvar changedProps = keys(newData).filter((prop) => self._data[prop] !== newData[prop]);\n\t\tobjectAssign(self._data, newData);\n\t\tself.notify(changedProps);\n\t}\n};\n\nexport { Store };", "const characterEntitiesMapping = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '&': '&amp;',\n  \"'\": '&apos;',\n  '\"': '&quot;',\n};\nfunction escape(text) {\n  if (!text) return text;\n  return text.replace(/[<>&'\"]/g, character => characterEntitiesMapping[character]);\n}\n// Utility for users not using a template library\nfunction html(strings, ...values) {\n  return strings.reduce((acc, string, index) => {\n    let value = String(values[index - 1]);\n    if ((strings[index - 1] || '').endsWith(\"$\")) {\n      // If $ sign precedes the interpolation, then its considered safe to\n      // add the unescaped / raw HTML\n      acc = acc.slice(0, -1);\n    } else {\n      value = escape(value);\n    }\n    return acc + value + string;\n  });\n}\n\nexport { html };"],
  "mappings": "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",
  "names": ["src_exports", "__export", "Pepper", "Store", "html", "from", "each", "arrayLike", "fn", "isCustomElement", "element", "attr", "keys", "obj", "key", "objectAssign", "target", "index", "getChildNodes", "el", "l", "node", "syncNode", "newNode", "liveNode", "each", "attr", "isCustomElement", "patchDom", "getCustomElementOuterHtml", "hashNode", "matchNodes", "a", "aStart", "aEnd", "b", "bStart", "bEnd", "domLookup", "newNodeToLiveNodeMatch", "i", "hash", "salvagableElements", "salvagableElementsById", "entry", "matched", "aLiveNode", "id", "parentNode", "newNodes", "aLen", "insertBefore", "oldStartNode", "oldEndNode", "startInsertBefore", "nodeAtPosition", "existingLiveNode", "Store", "initialData", "self", "newData", "changedProps", "keys", "prop", "changedPropsLookup", "acc", "subscriber", "changesPropsSubset", "propsToListenFor", "func", "context", "alreadyAdded", "objectAssign", "characterEntitiesMapping", "escape", "text", "character", "html", "strings", "values", "acc", "string", "index", "value", "merge", "out", "argIndex", "obj", "val", "keys", "keyIndex", "key", "parseAsFragment", "html", "templateTag", "traverseElements", "parentNode", "onNextNode", "treeWalker", "node", "isCustomElement", "Pepper", "config", "self", "mount", "hydrate", "objectAssign", "data", "handlerMap", "attachHandler", "context", "eventName", "func", "newMap", "removeAllHandlers", "callHandler", "event", "args", "from", "stores", "storeData", "acc", "storeKey", "store", "props", "acc2", "prop", "target", "focusId", "refVal", "frag", "els", "patchDom", "focusEl", "each", "attr", "hydrateOnly"]
}
