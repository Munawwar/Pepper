{
  "version": 3,
  "sources": ["../../../src/utils.js", "../../../src/dom-diff.js", "../../../src/store.js", "../../../src/html.js", "../../../src/index.js"],
  "sourcesContent": ["var from = Array.from;\n\nfunction each(arrayLike, fn) {\n\treturn Array.prototype.forEach.call(arrayLike, fn);\n}\n\nfunction isCustomElement(element) {\n\tif (element.tagName.indexOf('-') > 0) return true;\n\tvar attr = element.getAttribute('is');\n\treturn (attr && attr.indexOf('-') > 0);\n}\n\nfunction keys(obj) {\n\treturn Object.keys(obj).filter(key => key !== 'constructor');\n}\n// Safer Object.assign\nfunction objectAssign(target) {\n\tfrom(arguments).forEach((obj, index) => {\n\t\tif (!index) return;\n\t\tkeys(obj).forEach((key) => {\n\t\t\ttarget[key] = obj[key];\n\t\t});\n\t});\n\treturn target;\n}\n\nexport {\n  each,\n  isCustomElement,\n  from,\n  keys,\n  objectAssign,\n};", "import { from, each, isCustomElement } from './utils.js';\n\n/**\n * @param {Element} newNode\n * @param {Element} liveNode\n */\nfunction syncAttributes(newNode, liveNode) {\n\t// Remove any attributes from live node that is not in new node\n\teach(liveNode.attributes, (attr) => {\n\t\tif (!newNode.attributes.getNamedItem(attr.name)) {\n\t\t\tliveNode.attributes.removeNamedItem(attr.name);\n\t\t}\n\t});\n\n\t// update the rest\n\teach(newNode.attributes, (attr) => {\n\t\tif (liveNode.getAttribute(attr.name) !== attr.value) {\n\t\t\tliveNode.setAttribute(attr.name, attr.value);\n\t\t}\n\t});\n}\n\nfunction getCustomElementOuterHtml(el) {\n\treturn el.outerHTML.slice(0, -(el.innerHTML.length + el.tagName.length + 4)) + '/>';\n}\n/**\n * \n * @param {Node} node \n * @param {Map<Node, string>} cache \n * @returns {string}\n */\nfunction hashNode(node, cache) {\n\tvar hash = cache.get(node);\n\tif (!hash) {\n\t\thash = node.nodeType + ':' + (\n\t\t\t(node.nodeType === 1 ?\n\t\t\t\t(\n\t\t\t\t\tisCustomElement(node) ?\n\t\t\t\t\tgetCustomElementOuterHtml(node) :\n\t\t\t\t\t/** @type {Element} */ (node).outerHTML\n\t\t\t\t) :\n\t\t\t\t// comment, text, cdata node\n\t\t\t\tnode.nodeValue\n\t\t\t)\n\t\t);\n\t\tcache.set(node, hash);\n\t}\n\treturn hash;\n}\n\n/**\n * Assumptions:\n * 1. liveNodes are child nodes of parentNode\n * 2. no duplicates allowed within newNodes\n * 3. no duplicates allowed within liveNodes\n * 4. neither list should contain `after` node or any node before `after` node\n * @param {Node[]} newNodes\n * @param {Node[]} liveNodes\n * @param {Node} parentNode\n * @param {Node} [after] sync nodes after a specified node, so that the nodes before it doesn't get touched\n */\nfunction patchDom(newNodes, liveNodes, parentNode, after) {\n\n\t// fast path: case if newNodes.length is zero. means remove all\n\tif (!newNodes.length) {\n\t\tliveNodes.forEach(node => parentNode.removeChild(node));\n\t\treturn;\n\t}\n\n\t/** @type {Map<Node, string>} */\n\tvar nodeHashCache = new Map();\n\n\t/**\n\t * @typedef DomInfo\n\t * @property {Node[]} u unmatched\n\t * @property {Map<Node, Node>} n2l new node to live lookup\n\t */\n\t/**\n\t * Map from new nodes to old and back if available\n\t * @type {Record<string, DomInfo>}\n\t */\n\tvar domLookup = {};\n\tnewNodes.forEach((newNode) => {\n\t\tvar hash = hashNode(newNode, nodeHashCache);\n\t\tdomLookup[hash] = domLookup[hash] || {\n\t\t\tu: [],\n\t\t\tn2l: new Map(),\n\t\t};\n\t\tdomLookup[hash].u.push(newNode);\n\t});\n\t/**\n\t * we later want to re-use elements that don't have exact match if we can\n\t * @type {Record<string, Element[]>}\n\t */\n\tvar salvagableElements = {};\n\tliveNodes.forEach((liveNode) => {\n\t\tvar hash = hashNode(liveNode, nodeHashCache);\n\t\tvar entry = domLookup[hash];\n\t\tvar matched = false;\n\t\tif (entry) {\n\t\t\tvar newNode = entry.u.shift(); // pick first match\n\t\t\tif (newNode) {\n\t\t\t\tentry.n2l.set(newNode, liveNode);\n\t\t\t\tmatched = true;\n\t\t\t}\n\t\t}\n\t\tif (!matched && liveNode.nodeType === 1) {\n\t\t\tsalvagableElements[liveNode.nodeName] = salvagableElements[liveNode.nodeName] || [];\n\t\t\tsalvagableElements[liveNode.nodeName].push(/** @type {Element} */ (liveNode));\n\t\t}\n\t});\n\n\t// figure out where to start syncing from\n\tvar insertAt = from(parentNode.childNodes).indexOf(after) + 1;\n\tvar newLiveNodes = new Set();\n\n\t// re-ordering\n\t// we now look at new nodes top-to-bottom and order them exactly at it's final index\n\tnewNodes.forEach((newNode, index) => {\n\t\t// check for exact match live node\n\t\tvar hash = hashNode(newNode, nodeHashCache);\n\t\tvar existingLiveNode = domLookup[hash].n2l.get(newNode);\n\t\tvar nodeAtPosition = parentNode.childNodes[insertAt + index];\n\t\tif (existingLiveNode) {\n\t\t\tnewLiveNodes.add(existingLiveNode);\n\t\t\t// place it at the position. If nodeAtPosition is undefined, then inserts to end\n\t\t\tif (nodeAtPosition !== existingLiveNode) {\n\t\t\t\tparentNode.insertBefore(existingLiveNode, nodeAtPosition);\n\t\t\t}\n\t\t\t// else nothing to do if exact match is already at the right position\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// at this point we don't have an exact match node.\n\t\t// So for text, comment nodes just use the new nodes.\n\t\t// But for elements we can potentially re-use an existing element\n\t\t//\n\t\t// why? because there is a likely hood the node to be updated is a\n\t\t// \"similar looking\" element.\n\t\t// e.g. if the only update was an attribute update, and that node\n\t\t// happens to be a input element, it is worth keeping it so that\n\t\t// user doesn't potentially lose focus\n\n\t\tvar newNodeName = newNode.nodeName;\n\t\tif (\n\t\t\tnewNode.nodeType === 1\n\t\t\t&& (salvagableElements[newNodeName] && salvagableElements[newNodeName].length)\n\t\t) {\n\t\t\t// at this point we have an element that doesn't have an exact matching node.\n\t\t\t// but we do have an existing element of same nodeType that can be re-used\n\t\t\tvar newEl = /** @type {Element} */ (newNode); // gah, typescript!\n\t\t\tvar aLiveNode = salvagableElements[newNode.nodeName].shift(); // pick first one\n\t\t\tnewLiveNodes.add(aLiveNode);\n\t\t\t// place it at where the new node should be\n\t\t\tif (nodeAtPosition !== aLiveNode) {\n\t\t\t\tparentNode.insertBefore(aLiveNode, nodeAtPosition);\n\t\t\t}\n\t\t\tsyncAttributes(newEl, aLiveNode);\n\t\t\t// recursively sync children if innerHTML is different, except\n\t\t\t// custom elements (because encapsulation. reactivity with CE is via attributes only)\n\t\t\tif (!isCustomElement(newEl) && newEl.innerHTML != aLiveNode.innerHTML) {\n\t\t\t\tpatchDom(\n\t\t\t\t\tfrom(newEl.childNodes),\n\t\t\t\t\tfrom(aLiveNode.childNodes),\n\t\t\t\t\taLiveNode,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// At this point the node is either a text node, comment node or\n\t\t// an element that cant re-use another element.\n\t\tnewLiveNodes.add(newNode);\n\t\tparentNode.insertBefore(newNode, nodeAtPosition);\n\t});\n\n\t// now remove any element not in newLiveNodes\n\tliveNodes.forEach((node) => {\n\t\tif (!newLiveNodes.has(node)) {\n\t\t\tparentNode.removeChild(node);\n\t\t}\n\t});\n}\n\nexport { patchDom };", "import { keys, objectAssign } from './utils.js'\n\n// A store for Pepper views\n// it only does a shallow (i.e level 1) equality check of the store data properties\n// for notifying relevant connected views to re-render\n/**\n * @constructor\n * @param {Object} initialData\n */\nfunction Store(initialData) {\n\tvar self = this;\n\t/** @private */\n\tself._data = initialData || {};\n\t/** @private */\n\tself._subscribers = [];\n\n\tObject.defineProperty(this, 'data', {\n\t\tconfigurable: false,\n\t\tset(newData) {\n\t\t\tif (typeof newData !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar changedProps = [].concat(\n\t\t\t\t// find props that were changed\n\t\t\t\tkeys(newData).filter((prop) => self._data[prop] !== newData[prop]),\n\t\t\t\t// find props that got removed (i.e. not in new data)\n\t\t\t\tkeys(self._data).filter((prop) => !(prop in newData))\n\t\t\t);\n\t\t\tself._data = newData;\n\t\t\tself.notify(changedProps);\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n}\n\nStore.prototype = {\n\t/**\n\t * Reactive data - Getter/Setter\n\t */\n\tdata: {},\n\t/**\n\t * @private\n\t */\n\tnotify(changedProps) {\n\t\tvar changedPropsLookup = changedProps.reduce((acc, prop) => {\n\t\t\tacc[prop] = 1;\n\t\t\treturn acc;\n\t\t}, {});\n\t\tthis._subscribers.forEach((subscriber) => {\n\t\t\tvar changesPropsSubset = subscriber.props.filter((prop) => changedPropsLookup[prop]);\n\t\t\tif (changesPropsSubset.length) {\n\t\t\t\tsubscriber.callback.call(subscriber.context, changesPropsSubset);\n\t\t\t}\n\t\t});\n\t},\n\t/**\n\t * Subscribe to changes in global store properties\n\t * @param {string[]} propsToListenFor\n\t * @param {() => undefined} func\n\t * @param {any} [context]\n\t * @returns \n\t */\n\tsubscribe(propsToListenFor, func, context) {\n\t\tif (typeof func !== 'function' || !Array.isArray(propsToListenFor)) {\n\t\t\treturn;\n\t\t}\n\t\tvar self = this;\n\t\tvar alreadyAdded = self._subscribers.some((subscriber) => (\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t\tif (!alreadyAdded) {\n\t\t\tself._subscribers.push({\n\t\t\t\tprops: propsToListenFor,\n\t\t\t\tcallback: func,\n\t\t\t\tcontext: context\n\t\t\t});\n\t\t}\n\t},\n\tunsubscribe(func, context) {\n\t\tthis._subscribers = this._subscribers.filter((subscriber) => !(\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t},\n\tassign(newData) {\n\t\tvar self = this;\n\t\tif (typeof newData !== 'object') {\n\t\t\treturn;\n\t\t}\n\t\tvar changedProps = keys(newData).filter((prop) => self._data[prop] !== newData[prop]);\n\t\tobjectAssign(self._data, newData);\n\t\tself.notify(changedProps);\n\t}\n};\n\nexport { Store };", "const characterEntitiesMapping = {\n  '<': '&lt;',\n  '>': '&gt;',\n  '&': '&amp;',\n  \"'\": '&apos;',\n  '\"': '&quot;',\n};\nfunction escape(text) {\n  if (!text) return text;\n  return text.replace(/[<>&'\"]/g, character => characterEntitiesMapping[character]);\n}\n// Utility for users not using a template library\nfunction html(strings, ...values) {\n  return strings.reduce((acc, string, index) => {\n    let value = String(values[index - 1]);\n    if ((strings[index - 1] || '').endsWith(\"$\")) {\n      // If $ sign precedes the interpolation, then its considered safe to\n      // add the unescaped / raw HTML\n      acc = acc.slice(0, -1);\n    } else {\n      value = escape(value);\n    }\n    return acc + value + string;\n  });\n}\n\nexport { html };", "// utils\nimport {\n\tfrom,\n\tobjectAssign,\n\teach,\n\tisCustomElement\n} from './utils.js';\nimport { patchDom } from './dom-diff.js';\nimport { Store } from './store.js';\nimport { html } from './html.js';\n\n// Deep merge helper\nfunction merge(out) {\n\tout = out || {};\n\tfor (var argIndex = 1; argIndex < arguments.length; argIndex++) {\n\t\tvar obj = arguments[argIndex];\n\t\tif (!obj || typeof val !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\t\tvar keys = keys(obj);\n\t\tfor (var keyIndex = 1; keyIndex < keys.length; keyIndex++) {\n\t\t\tvar key = keys[keyIndex];\n\t\t\tvar val = obj[key];\n\t\t\tout[key] = (typeof val === 'object' && val !== null)\n\t\t\t\t? merge(out[key], val)\n\t\t\t\t: val;\n\t\t}\n\t}\n\treturn out;\n}\n/**\n * Converts html string to a document fragment.\n * @param {String} html\n * @return {DocumentFragment}\n * @method dom\n */\nfunction parseAsFragment(html) {\n\tvar templateTag = document.createElement('template');\n\ttemplateTag.innerHTML = html;\n\treturn templateTag.content;\n}\n\n/**\n * Traverse elements of a tree in order of visibility (pre-order traversal)\n * @param {Node} parentNode\n * @param {(Node) => void} onNextNode\n */\nfunction traverseElements(parentNode, onNextNode) {\n\tvar treeWalker = document.createTreeWalker(parentNode, NodeFilter.SHOW_ELEMENT),\n\t\t\tnode = treeWalker.nextNode();\n\twhile (node) {\n\t\t// dont touch the inner nodes of custom elements\n\t\tif (isCustomElement(node)) {\n\t\t\tnode = treeWalker.nextSibling();\n\t\t\tcontinue;\n\t\t}\n\t\tonNextNode(node);\n\t\tnode = treeWalker.nextNode();\n\t}\n}\n\n/**\n * @template DataType\n * @param {Object} config \n * @param {HTMLElement} config.target\n * @param {DataType} config.data\n * @param {(data: DataType) => String} config.getHtml\n * @param {Boolean} [config.mount=false]\n * @param {Boolean} [config.hydrate=false]\n * @param {{ store: Store, props: String[] }} [config.connect]\n */\nfunction Pepper(config) {\n\tvar self = this;\n\tself._data = (typeof config.data === 'object' && config.data) || {};\n\tvar mount = config.mount;\n\tvar hydrate = config.hydrate;\n\t\n\tdelete config.data;\n\tdelete config.mount;\n\tdelete config.hydrate;\n\tobjectAssign(self, config);\n\tObject.defineProperty(self, 'data', {\n\t\tconfigurable: false,\n\t\tset(data) {\n\t\t\tself._data = data;\n\t\t\t// TODO: only render if there is a change\n\t\t\tself.render();\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n\tif (hydrate) {\n\t\tself.hydrate()\n\t} else if (mount) {\n\t\tself.mount();\n\t}\n}\n\n// private\nvar handlerMap = new WeakMap();\n/**\n * Helper to attach handleEvent object event listener to element.\n * @param {HTMLElement} node\n * @param {Object} context\n * @param {String} eventName\n * @param {Function} func\n */\nfunction attachHandler(node, context, eventName, func) {\n\tif (!func) return;\n\tvar newMap = handlerMap.get(node) || {};\n\tnewMap[eventName] = func;\n\thandlerMap.set(node, newMap);\n\tnode.addEventListener(eventName, context);\n}\n/**\n * Removes all event handlers on node. Ensure same context is passed as it\n * was for attachHandler() function, else the event listeners wont get removed.\n */\nfunction removeAllHandlers(node, context) {\n\tObject.keys(handlerMap.get(node) || {}).forEach(function (eventName) {\n\t\tnode.removeEventListener(eventName, context);\n\t});\n\thandlerMap.delete(node);\n}\n/**\n * Invokes an event handler that was registered via attachHandler\n * @param {Pepper} context \n * @param {Event} event \n */\nfunction callHandler(context, event) {\n\tvar node = event.currentTarget;\n\tvar func = (handlerMap.get(node) || {})[event.type];\n\tif (func) {\n\t\tfunc.call(context, event);\n\t}\n}\n\n// Methods and properties\nPepper.prototype = {\n\t/**\n\t * The data object.\n\t * This is a private variable accessed through this.data\n\t * setter/getter.\n\t */\n\t_data: null,\n\n\t/**\n\t * (Optional) The element to replace (on first render).\n\t */\n\ttarget: null,\n\n\t/**\n\t * (Optional) A Pepper store and array of props to listen to. The properties will be mixed with\n\t * `data` passed to this.getHtml() function (in case of collision local data takes precedence\n\t * over store data). This instance will re-render (when mounted) when the specified props change\n\t * in the global store\n\t * Example: ['cart', 'wishlist']\n\t * @type {{\n\t * \tstore: Pepper.Store,\n\t *  props: string[]\n\t * }}\n\t */\n\tconnect: {},\n\n\t/**\n\t * Function that returns component's html to be rendered\n\t * @param {any} data combined data from this.data and connected pepper store data\n\t * @returns {string}\n\t */\n\tgetHtml() { return ''; },\n\t\n\t/**\n\t * Set data on this.data (using Object.assign), and re-render.\n\t */\n\tassign() {\n\t\tvar args = from(arguments);\n\t\tobjectAssign.apply(null, [this.data].concat(args));\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\t/**\n\t * Deep merge data with this.data, and re-render.\n\t */\n\tmerge(data) {\n\t\tmerge(this.data, data);\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\thandleEvent(event) {\n\t\tcallHandler(this, event);\n\t},\n\n\ttoString: function renderToString() {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tvar storeData = (connect && connect.store && connect.store._data) || {};\n\t\tvar storeDataSubset = ((connect && connect.props) || []).reduce((acc, prop) => {\n\t\t\tacc[prop] = storeData[prop];\n\t\t\treturn acc;\n\t\t}, {});\n\t\tvar data = objectAssign(storeDataSubset, self.data);\n\t\treturn self.getHtml(data);\n\t},\n\n\t/**\n\t * Render view.\n\t * If this.target or node parameter is specified, then replaces that node and attaches the\n\t * rendered DOM to document (or document fragment).\n\t *\n\t * @private\n\t */\n\trender() {\n\t\t// Step 1: Remove event listeners and refs\n\t\t// Step 2: Note the currently focused element\n\t\t// Step 3: Render/Update UI.\n\t\t// Step 4: Resolve references\n\t\t// Step 5: Re-focus\n\t\t// Step 6: Re-attach listeners\n\t\t\n\t\tvar self = this;\n\t\tvar target = self.el;\n\n\t\t// Step 1: Find input field focus, remember it's id attribute, so that it\n\t\t// can be refocused later.\n\t\tvar focusId = document.activeElement.id;\n\n\t\t// Step 2: Remove event listeners and refs before patch.\n\t\tif (target) {\n\t\t\ttraverseElements(target, (node) => {\n\t\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\t\tif (refVal && self[refVal] instanceof Node) {\n\t\t\t\t\tdelete self[refVal];\n\t\t\t\t}\n\t\t\t\tif (handlerMap.has(node)) {\n\t\t\t\t\tremoveAllHandlers(node, self);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Step 3: Render/Update UI\n\t\tvar frag = parseAsFragment(self.toString());\n\t\tvar els = from(frag.childNodes)\n\t\t// var el = frag.firstElementChild;\n\n\t\t// Update existing DOM.\n\t\tif (target) {\n\t\t\tvar live = from(target.childNodes);\n\t\t\tpatchDom(els, live, target);\n\t\t}\n\n\t\t// Step 4: Re-focus\n\t\tif (focusId) {\n\t\t\tvar focusEl = document.getElementById(focusId);\n\t\t\tif (focusEl) {\n\t\t\t\tfocusEl.focus();\n\t\t\t}\n\t\t}\n\n\t\tself.domHydrate();\n\t},\n\n\t/**\n\t * @private\n\t */\n\tdomHydrate() {\n\t\t// Doing step 5 and 6 from render() function\n\t\t// Step 5: Resolve refs\n\t\t// Step 6: Attach event listeners\n\n\t\tvar self = this;\n\t\t// TODO: only set this on debug mode\n\t\tself.el.pepperInstance = self;\n\n\t\t// Note: ref creates a reference to the node as property on the view.\n\t\ttraverseElements(self.el, (node) => {\n\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\tif (refVal) {\n\t\t\t\tself[refVal] = node;\n\t\t\t}\n\t\t\teach(node.attributes, (attr) => {\n\t\t\t\tif (attr.name.startsWith('on-')) {\n\t\t\t\t\tvar eventName = attr.name.replace(/on-/, '');\n\t\t\t\t\tattachHandler(node, self, eventName, self[attr.value]);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * @param {Boolean} [hydrateOnly=false] does a full render by default. 'Hydration' only\n\t * attaches event listeners and resolves refs.\n\t * @returns \n\t */\n\tmount(hydrateOnly = false) {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tif (connect && connect.store) {\n\t\t\tconnect.store.subscribe(connect.props, self.render, self);\n\t\t}\n\n\t\tvar node = self.target;\n\t\tif (typeof node === 'string') {\n\t\t\tnode = document.querySelector(node);\n\t\t}\n\n\t\t// Return if already mounted.\n\t\tif (self.el && node === self.el) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node) {\n\t\t\tself.el = node;\n\t\t\tif (hydrateOnly) {\n\t\t\t\tself.domHydrate();\n\t\t\t} else { // full render\n\t\t\t\tself.render();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\thydrate(data) {\n\t\tif (arguments.length > 0 && data && typeof data === 'object') {\n\t\t\tthis._data = data;\n\t\t}\n\t\tthis.mount(true);\n\t},\n\n\tunmount() {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tif (connect && connect.store) {\n\t\t\tconnect.store.unsubscribe(self.render, self);\n\t\t}\n\t\tself.el.replaceChildren(); // empty replaceChildren removes all child elements\n\t}\n};\n\nexport { Pepper, Store, html };\n"],
  "mappings": "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",
  "names": ["from", "each", "arrayLike", "fn", "isCustomElement", "element", "attr", "keys", "obj", "key", "objectAssign", "target", "index", "syncAttributes", "newNode", "liveNode", "each", "attr", "getCustomElementOuterHtml", "el", "hashNode", "node", "cache", "hash", "isCustomElement", "patchDom", "newNodes", "liveNodes", "parentNode", "after", "nodeHashCache", "domLookup", "salvagableElements", "entry", "matched", "insertAt", "from", "newLiveNodes", "index", "existingLiveNode", "nodeAtPosition", "newNodeName", "newEl", "aLiveNode", "Store", "initialData", "self", "newData", "changedProps", "keys", "prop", "changedPropsLookup", "acc", "subscriber", "changesPropsSubset", "propsToListenFor", "func", "context", "alreadyAdded", "objectAssign", "characterEntitiesMapping", "escape", "text", "character", "html", "strings", "values", "acc", "string", "index", "value", "merge", "out", "argIndex", "obj", "val", "keys", "keyIndex", "key", "parseAsFragment", "html", "templateTag", "traverseElements", "parentNode", "onNextNode", "treeWalker", "node", "isCustomElement", "Pepper", "config", "self", "mount", "hydrate", "objectAssign", "data", "handlerMap", "attachHandler", "context", "eventName", "func", "newMap", "removeAllHandlers", "callHandler", "event", "args", "from", "connect", "storeData", "storeDataSubset", "acc", "prop", "target", "focusId", "refVal", "frag", "els", "live", "patchDom", "focusEl", "each", "attr", "hydrateOnly"]
}
