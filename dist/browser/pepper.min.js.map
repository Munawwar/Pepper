{
  "version": 3,
  "sources": ["../../pepper.js"],
  "sourcesContent": ["var from = Array.from;\n// utils\nfunction each(arrayLike, fn) {\n\treturn Array.prototype.forEach.call(arrayLike, fn);\n}\nfunction keys(obj) {\n\treturn Object.keys(obj).filter(key => key !== 'constructor');\n}\n// Safer Object.assign\nfunction objectAssign(target) {\n\tfrom(arguments).forEach((obj, index) => {\n\t\tif (!index) return;\n\t\tkeys(obj).forEach((key) => {\n\t\t\ttarget[key] = obj[key];\n\t\t});\n\t});\n\treturn target;\n}\n// Deep merge helper\nfunction merge(out) {\n\tout = out || {};\n\tfor (var argIndex = 1; argIndex < arguments.length; argIndex += 1) {\n\t\tvar obj = arguments[argIndex];\n\t\tif (!obj || typeof val !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\t\tvar keys = keys(obj);\n\t\tfor (var keyIndex = 1; keyIndex < keys.length; keyIndex += 1) {\n\t\t\tvar key = keys[keyIndex];\n\t\t\tvar val = obj[key];\n\t\t\tout[key] = (typeof val === 'object' && val !== null)\n\t\t\t\t? merge(out[key], val)\n\t\t\t\t: val;\n\t\t}\n\t}\n\treturn out;\n}\n/**\n * Converts html string to a document fragment.\n * @param {String} html\n * @return {DocumentFragment}\n * @method dom\n */\nfunction parseAsFragment(html) {\n\tvar templateTag = document.createElement('template');\n\ttemplateTag.innerHTML = html;\n\tvar frag = templateTag.content;\n\t// remove script tags\n\tvar toRemove = frag.querySelectorAll('script');\n\tfor (var i = 0; i < toRemove.length; i += 1) {\n\t\tfrag.removeChild(toRemove[i])\n\t}\n\treturn frag;\n}\n\nfunction isCustomElement(element) {\n\tif (element.tagName.indexOf('-') > 0) return true;\n\tvar attr = element.getAttribute('is');\n\treturn (attr && attr.indexOf('-') > 0);\n}\n/**\n * Traverse elements of a tree in order of visibility (pre-order traversal)\n * @param {Node} parentNode\n * @param {(Node) => void} onNextNode\n */\nfunction traverseElements(parentNode, onNextNode) {\n\tvar treeWalker = document.createTreeWalker(parentNode, NodeFilter.SHOW_ELEMENT),\n\t\t\tnode = treeWalker.nextNode();\n\twhile (node) {\n\t\t// dont touch the inner nodes of custom elements\n\t\tif (isCustomElement(node)) {\n\t\t\tnode = treeWalker.nextSibling();\n\t\t\tcontinue;\n\t\t}\n\t\tonNextNode(node);\n\t\tnode = treeWalker.nextNode();\n\t}\n}\n\n// -- dom-sync logic --\n/**\n * @param {Element} newNode\n * @param {Element} liveNode\n */\nfunction syncAttributes(newNode, liveNode) {\n\t// Remove any attributes from live node that is not in new node\n\teach(liveNode.attributes, (attr) => {\n\t\tif (!newNode.attributes.getNamedItem(attr.name)) {\n\t\t\tliveNode.attributes.removeNamedItem(attr.name);\n\t\t}\n\t});\n\n\t// update the rest\n\teach(newNode.attributes, (attr) => {\n\t\tif (liveNode.getAttribute(attr.name) !== attr.value) {\n\t\t\tliveNode.setAttribute(attr.name, attr.value);\n\t\t}\n\t});\n}\n\nfunction getCustomElementOuterHtml(el) {\n\treturn el.outerHTML.slice(0, -(el.innerHTML.length + el.tagName.length + 4)) + '/>';\n}\n/**\n * \n * @param {Node} node \n * @param {WeakMap<Node, string>} cache \n * @returns {string}\n */\nfunction hashNode(node, cache) {\n\tvar hash = cache.get(node);\n\tif (!hash) {\n\t\thash = node.nodeType + ':' + (\n\t\t\t(node.nodeType === 1 ?\n\t\t\t\t(\n\t\t\t\t\tisCustomElement(node) ?\n\t\t\t\t\tgetCustomElementOuterHtml(node) :\n\t\t\t\t\t/** @type {Element} */ (node).outerHTML\n\t\t\t\t) :\n\t\t\t\t// comment, text, cdata node\n\t\t\t\tnode.nodeValue\n\t\t\t)\n\t\t);\n\t\tcache.set(node, hash);\n\t}\n\treturn hash;\n}\n\n/**\n * Assumptions:\n * 1. liveNodes are child nodes of parentNode\n * 2. no duplicates allowed within newNodes\n * 3. no duplicates allowed within liveNodes\n * 4. neither list should contain `after` node or any node before `after` node\n * @param {Node[]} newNodes\n * @param {Node[]} liveNodes\n * @param {Node} parentNode\n * @param {Node} [after] sync nodes after a specified node, so that the nodes before it doesn't get touched\n */\nfunction patchDom(newNodes, liveNodes, parentNode, after) {\n\n\t// fast path: case if newNodes.length is zero. means remove all\n\tif (!newNodes.length) {\n\t\tliveNodes.forEach(node => parentNode.removeChild(node));\n\t\treturn;\n\t}\n\n\t/** @type {WeakMap<Node, string>} */\n\tvar nodeHashCache = new WeakMap();\n\n\t/**\n\t * @typedef DomInfo\n\t * @property {Node[]} u unmatched\n\t * @property {Map<Node, Node>} n2l new node to live lookup\n\t * @property {Map<Node, Node>} l2n live node to new lookup\n\t */\n\t/**\n\t * Map from new nodes to old and back if available\n\t * @type {Record<string, DomInfo>}\n\t */\n\tvar domLookup = {};\n\tnewNodes.forEach((newNode) => {\n\t\tvar hash = hashNode(newNode, nodeHashCache);\n\t\tdomLookup[hash] = domLookup[hash] || {\n\t\t\tu: [],\n\t\t\tn2l: new Map(),\n\t\t\tl2n: new Map(),\n\t\t};\n\t\tdomLookup[hash].u.push(newNode);\n\t});\n\tvar numberOfMatches = 0;\n\t/**\n\t * we later want to re-use elements that don't have exact match if we can\n\t * @type {Record<string, Element[]>}\n\t */\n\tvar salvagableElements = {};\n\tliveNodes.forEach((liveNode) => {\n\t\tvar hash = hashNode(liveNode, nodeHashCache);\n\t\tvar entry = domLookup[hash];\n\t\tvar matched = false;\n\t\tif (entry) {\n\t\t\tvar newNode = entry.u.shift(); // pick first match\n\t\t\tif (newNode) {\n\t\t\t\tentry.n2l.set(newNode, liveNode);\n\t\t\t\tentry.l2n.set(liveNode, newNode);\n\t\t\t\tmatched = true;\n\t\t\t\tnumberOfMatches++;\n\t\t\t}\n\t\t}\n\t\tif (!matched && liveNode.nodeType === 1) {\n\t\t\tsalvagableElements[liveNode.nodeName] = salvagableElements[liveNode.nodeName] || [];\n\t\t\tsalvagableElements[liveNode.nodeName].push(/** @type {Element} */ (liveNode));\n\t\t}\n\t});\n\n\t// optimization for removals\n\t// if all new nodes have matching live nodes, then we can safely\n\t// remove remaining (non-matching) live nodes before re-ordering\n\t// so if live nodes are already in order (as in the case of many\n\t// conditional rendering), re-ordering will be a no-op.\n\tif (numberOfMatches === newNodes.length && liveNodes.length > newNodes.length) {\n\t\t// remove from end so that it doesn't affect iteration\n\t\tfor (var i = liveNodes.length - 1; i>= 0; i--) {\n\t\t\tvar liveNode = liveNodes[i];\n\t\t\tvar hash = hashNode(liveNode, nodeHashCache);\n\t\t\tif (!domLookup[hash] || !domLookup[hash].l2n.has(liveNode)) {\n\t\t\t\t// remove from live DOM and from liveNodes list\n\t\t\t\tparentNode.removeChild(liveNode);\n\t\t\t\tliveNodes.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// figure out where to start syncing from\n\tvar insertAt = from(parentNode.childNodes).indexOf(after) + 1;\n\tvar newLiveNodes = new Set();\n\n\t// re-ordering\n\t// we now look at new nodes top-to-bottom and order them exactly at it's final index\n\tnewNodes.forEach((newNode, index) => {\n\t\t// check for exact match live node\n\t\tvar hash = hashNode(newNode, nodeHashCache);\n\t\tvar existingLiveNode = domLookup[hash].n2l.get(newNode);\n\t\tvar nodeAtPosition = parentNode.childNodes[insertAt + index];\n\t\tif (existingLiveNode) {\n\t\t\tnewLiveNodes.add(existingLiveNode);\n\t\t\t// put it at the position. If nodeAtPosition is undefined, then inserts to end\n\t\t\tif (nodeAtPosition !== existingLiveNode) {\n\t\t\t\tparentNode.insertBefore(existingLiveNode, nodeAtPosition);\n\t\t\t}\n\t\t\t// else nothing to do if exact match is already at the right position\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// at this point we don't have an exact match node.\n\t\t// So for text, comment nodes just use the new nodes.\n\t\t// But for elements we can potentially re-use an existing element\n\t\t//\n\t\t// why? because there is a likely hood the node to be updated is a\n\t\t// \"similar looking\" element.\n\t\t// e.g. if the only update was an attribute update, and that node\n\t\t// happens to be a input element, it is worth keeping it so that\n\t\t// user doesn't potentially lose focus\n\n\t\tvar newNodeName = newNode.nodeName;\n\t\tif (\n\t\t\tnewNode.nodeType !== 1\n\t\t\t|| !salvagableElements[newNodeName]\n\t\t\t|| !salvagableElements[newNodeName].length\n\t\t) {\n\t\t\tnewLiveNodes.add(newNode);\n\t\t\tparentNode.insertBefore(newNode, nodeAtPosition);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// at this point we have an element that doesn't have an exact matching node.\n\t\t// but we do have an existing element of same nodeType that can be re-used\n\t\tvar newEl = /** @type {Element} */ (newNode); // gah, typescript!\n\t\tvar aLiveNode = salvagableElements[newNode.nodeName].shift(); // pick first one\n\t\tnewLiveNodes.add(aLiveNode);\n\t\t// place it at where the new node should be\n\t\tif (nodeAtPosition !== aLiveNode) {\n\t\t\tparentNode.insertBefore(aLiveNode, nodeAtPosition);\n\t\t}\n\t\tsyncAttributes(newEl, aLiveNode);\n\t\t// recursively sync children, except for custom elements (because encapsulation\n\t\t// - reactivity with CE is via attributes only)\n\t\tif (!isCustomElement(newEl)) {\n\t\t\tpatchDom(\n\t\t\t\tfrom(newEl.childNodes),\n\t\t\t\tfrom(aLiveNode.childNodes),\n\t\t\t\taLiveNode,\n\t\t\t);\n\t\t}\n\t});\n\n\t// now remove any element not in newLiveNodes\n\tliveNodes.forEach((node) => {\n\t\tif (!newLiveNodes.has(node)) {\n\t\t\tparentNode.removeChild(node);\n\t\t}\n\t});\n}\n// -- end of dom-sync logic --\n\n/**\n * @template DataType\n * @param {Object} config \n * @param {HTMLElement} config.target\n * @param {DataType} config.data\n * @param {(data: DataType) => String} config.getHtml\n * @param {Boolean} [config.mount=false]\n * @param {Boolean} [config.hydrate=false]\n * @param {{ store: Pepper.Store, props: String[] }} [config.connect]\n */\nfunction Pepper(config) {\n\tvar self = this;\n\tself._data = (typeof config.data === 'object' && config.data) || {};\n\tvar mount = config.mount;\n\tvar hydrate = config.hydrate;\n\t\n\tdelete config.data;\n\tdelete config.mount;\n\tdelete config.hydrate;\n\tobjectAssign(self, config);\n\tObject.defineProperty(self, 'data', {\n\t\tconfigurable: false,\n\t\tset(data) {\n\t\t\tself._data = data;\n\t\t\t// TODO: only render if there is a change\n\t\t\tself.render();\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n\tif (hydrate) {\n\t\tself.hydrate()\n\t} else if (mount) {\n\t\tself.mount();\n\t}\n}\n\n// private\nvar handlerMap = new WeakMap();\n/**\n * Helper to attach handleEvent object event listener to element.\n * @param {HTMLElement} node\n * @param {Object} context\n * @param {String} eventName\n * @param {Function} func\n */\nfunction attachHandler(node, context, eventName, func) {\n\tif (!func) return;\n\tvar newMap = handlerMap.get(node) || {};\n\tnewMap[eventName] = func;\n\thandlerMap.set(node, newMap);\n\tnode.addEventListener(eventName, context);\n}\n/**\n * Removes all event handlers on node. Ensure same context is passed as it\n * was for attachHandler() function, else the event listeners wont get removed.\n */\nfunction removeAllHandlers(node, context) {\n\tObject.keys(handlerMap.get(node) || {}).forEach(function (eventName) {\n\t\tnode.removeEventListener(eventName, context);\n\t});\n\thandlerMap.delete(node);\n}\n/**\n * Invokes an event handler that was registered via attachHandler\n * @param {Pepper} context \n * @param {Event} event \n */\nfunction callHandler(context, event) {\n\tvar node = event.currentTarget;\n\tvar func = (handlerMap.get(node) || {})[event.type];\n\tif (func) {\n\t\tfunc.call(context, event);\n\t}\n}\n\n// Static methods and properties\n// a global store for Pepper views (it's like a singleton global redux store)\n// it only does a shallow (i.e level 1) equality check of the store data properties\n// for notifying relevant connected views to re-render\n/**\n * @constructor\n * @param {Object} initialData\n */\nPepper.Store = function PepperStore(initialData) {\n\tvar self = this;\n\t/** @private */\n\tself._data = initialData || {};\n\t/** @private */\n\tself._subscribers = [];\n\n\tObject.defineProperty(this, 'data', {\n\t\tconfigurable: false,\n\t\tset(newData) {\n\t\t\tif (typeof newData !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar changedProps = [].concat(\n\t\t\t\t// find props that were changed\n\t\t\t\tkeys(newData).filter((prop) => self._data[prop] !== newData[prop]),\n\t\t\t\t// find props that got removed (i.e. not in new data)\n\t\t\t\tkeys(self._data).filter((prop) => !(prop in newData))\n\t\t\t);\n\t\t\tself._data = newData;\n\t\t\tself.notify(changedProps);\n\t\t},\n\t\tget() {\n\t\t\treturn self._data;\n\t\t}\n\t});\n}\n\nPepper.Store.prototype = {\n\t/**\n\t * Reactive data - Getter/Setter\n\t */\n\tdata: {},\n\t/**\n\t * @private\n\t */\n\tnotify(changedProps) {\n\t\tvar changedPropsLookup = changedProps.reduce((acc, prop) => {\n\t\t\tacc[prop] = 1;\n\t\t\treturn acc;\n\t\t}, {});\n\t\tthis._subscribers.forEach((subscriber) => {\n\t\t\tvar changesPropsSubset = subscriber.props.filter((prop) => changedPropsLookup[prop]);\n\t\t\tif (changesPropsSubset.length) {\n\t\t\t\tsubscriber.callback.call(subscriber.context, changesPropsSubset);\n\t\t\t}\n\t\t});\n\t},\n\t/**\n\t * Subscribe to changes in global store properties\n\t * @param {string[]} propsToListenFor\n\t * @param {() => undefined} func\n\t * @param {any} [context]\n\t * @returns \n\t */\n\tsubscribe(propsToListenFor, func, context) {\n\t\tif (typeof func !== 'function' || !Array.isArray(propsToListenFor)) {\n\t\t\treturn;\n\t\t}\n\t\tvar self = this;\n\t\tvar alreadyAdded = self._subscribers.some((subscriber) => (\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t\tif (!alreadyAdded) {\n\t\t\tself._subscribers.push({\n\t\t\t\tprops: propsToListenFor,\n\t\t\t\tcallback: func,\n\t\t\t\tcontext: context\n\t\t\t});\n\t\t}\n\t},\n\tunsubscribe(func, context) {\n\t\tthis._subscribers = this._subscribers.filter((subscriber) => !(\n\t\t\tsubscriber.callback === func && (context === undefined || context === subscriber.context)\n\t\t));\n\t},\n\tassign(newData) {\n\t\tvar self = this;\n\t\tif (typeof newData !== 'object') {\n\t\t\treturn;\n\t\t}\n\t\tvar changedProps = keys(newData).filter((prop) => self._data[prop] !== newData[prop]);\n\t\tobjectAssign(self._data, newData);\n\t\tself.notify(changedProps);\n\t}\n};\n\n// Methods and properties\nPepper.prototype = {\n\t/**\n\t * The data object.\n\t * This is a private variable accessed through this.data\n\t * setter/getter.\n\t */\n\t_data: null,\n\n\t/**\n\t * (Optional) The element to replace (on first render).\n\t */\n\ttarget: null,\n\n\t/**\n\t * (Optional) A Pepper store and array of props to listen to. The properties will be mixed with\n\t * `data` passed to this.getHtml() function (in case of collision local data takes precedence\n\t * over store data). This instance will re-render (when mounted) when the specified props change\n\t * in the global store\n\t * Example: ['cart', 'wishlist']\n\t * @type {{\n\t * \tstore: Pepper.Store,\n\t *  props: string[]\n\t * }}\n\t */\n\tconnect: {},\n\n\t/**\n\t * Function that returns component's html to be rendered\n\t * @param {any} data combined data from this.data and connected pepper store data\n\t * @returns {string}\n\t */\n\tgetHtml() { return ''; },\n\t\n\t/**\n\t * Set data on this.data (using Object.assign), and re-render.\n\t */\n\tassign() {\n\t\tvar args = from(arguments);\n\t\tobjectAssign.apply(null, [this.data].concat(args));\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\t/**\n\t * Deep merge data with this.data, and re-render.\n\t */\n\tmerge(data) {\n\t\tmerge(this.data, data);\n\t\t// TODO: only render if there is a change\n\t\tthis.render();\n\t},\n\n\thandleEvent(event) {\n\t\tcallHandler(this, event);\n\t},\n\n\ttoString: function renderToString() {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tvar storeData = (connect && connect.store && connect.store._data) || {};\n\t\tvar storeDataSubset = ((connect && connect.props) || []).reduce((acc, prop) => {\n\t\t\tacc[prop] = storeData[prop];\n\t\t\treturn acc;\n\t\t}, {});\n\t\tvar data = objectAssign(storeDataSubset, self.data);\n\t\treturn self.getHtml(data);\n\t},\n\n\t/**\n\t * Render view.\n\t * If this.target or node parameter is specified, then replaces that node and attaches the\n\t * rendered DOM to document (or document fragment).\n\t *\n\t * @private\n\t */\n\trender() {\n\t\t// Step 1: Remove event listeners and refs\n\t\t// Step 2: Note the currently focused element\n\t\t// Step 3: Render/Update UI.\n\t\t// Step 4: Resolve references\n\t\t// Step 5: Re-focus\n\t\t// Step 6: Re-attach listeners\n\t\t\n\t\tvar self = this;\n\t\tvar target = self.el;\n\n\t\t// Step 1: Find input field focus, remember it's id attribute, so that it\n\t\t// can be refocused later.\n\t\tvar focusId = document.activeElement.id;\n\n\t\t// Step 2: Remove event listeners and refs before patch.\n\t\tif (target) {\n\t\t\ttraverseElements(target, (node) => {\n\t\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\t\tif (refVal && self[refVal] instanceof Node) {\n\t\t\t\t\tdelete self[refVal];\n\t\t\t\t}\n\t\t\t\tif (handlerMap.has(node)) {\n\t\t\t\t\tremoveAllHandlers(node, self);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Step 3: Render/Update UI\n\t\tvar frag = parseAsFragment(self.toString());\n\t\tvar els = from(frag.childNodes)\n\t\t// var el = frag.firstElementChild;\n\n\t\t// Update existing DOM.\n\t\tif (target) {\n\t\t\tvar live = from(target.childNodes);\n\t\t\tpatchDom(els, live, target);\n\t\t}\n\n\t\t// Step 4: Re-focus\n\t\tif (focusId) {\n\t\t\tvar focusEl = document.getElementById(focusId);\n\t\t\tif (focusEl) {\n\t\t\t\tfocusEl.focus();\n\t\t\t}\n\t\t}\n\n\t\tself.domHydrate();\n\t},\n\n\t/**\n\t * @private\n\t */\n\tdomHydrate() {\n\t\t// Doing step 5 and 6 from render() function\n\t\t// Step 5: Resolve refs\n\t\t// Step 6: Attach event listeners\n\n\t\tvar self = this;\n\t\t// TODO: only set this on debug mode\n\t\tself.el.pepperInstance = self;\n\n\t\t// Note: ref creates a reference to the node as property on the view.\n\t\ttraverseElements(self.el, (node) => {\n\t\t\tvar refVal = node.getAttribute('ref');\n\t\t\tif (refVal) {\n\t\t\t\tself[refVal] = node;\n\t\t\t}\n\t\t\teach(node.attributes, (attr) => {\n\t\t\t\tif (attr.name.startsWith('on-')) {\n\t\t\t\t\tvar eventName = attr.name.replace(/on-/, '');\n\t\t\t\t\tattachHandler(node, self, eventName, self[attr.value]);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * @param {Boolean} [hydrateOnly=false] does a full render by default. 'Hydration' only\n\t * attaches event listeners and resolves refs.\n\t * @returns \n\t */\n\tmount(hydrateOnly = false) {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tif (connect && connect.store) {\n\t\t\tconnect.store.subscribe(connect.props, self.render, self);\n\t\t}\n\n\t\tvar node = self.target;\n\t\tif (typeof node === 'string') {\n\t\t\tnode = document.querySelector(node);\n\t\t}\n\n\t\t// Return if already mounted.\n\t\tif (self.el && node === self.el) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (node) {\n\t\t\tself.el = node;\n\t\t\tif (hydrateOnly) {\n\t\t\t\tself.domHydrate();\n\t\t\t} else { // full render\n\t\t\t\tself.render();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\thydrate(data) {\n\t\tif (arguments.length > 0 && data && typeof data === 'object') {\n\t\t\tthis._data = data;\n\t\t}\n\t\tthis.mount(true);\n\t},\n\n\tunmount() {\n\t\tvar self = this;\n\t\tvar connect = self.connect;\n\t\tif (connect && connect.store) {\n\t\t\tconnect.store.unsubscribe(self.render, self);\n\t\t}\n\t\tself.el.replaceChildren(); // empty replaceChildren removes all child elements\n\t}\n};\n\nexport default Pepper;\n"],
  "mappings": "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",
  "names": ["pepper_exports", "__export", "pepper_default", "from", "each", "arrayLike", "fn", "keys", "obj", "key", "objectAssign", "target", "index", "merge", "out", "argIndex", "val", "keyIndex", "parseAsFragment", "html", "templateTag", "frag", "toRemove", "i", "isCustomElement", "element", "attr", "traverseElements", "parentNode", "onNextNode", "treeWalker", "node", "syncAttributes", "newNode", "liveNode", "getCustomElementOuterHtml", "el", "hashNode", "cache", "hash", "patchDom", "newNodes", "liveNodes", "after", "nodeHashCache", "domLookup", "numberOfMatches", "salvagableElements", "entry", "matched", "insertAt", "newLiveNodes", "existingLiveNode", "nodeAtPosition", "newNodeName", "newEl", "aLiveNode", "Pepper", "config", "self", "mount", "hydrate", "data", "handlerMap", "attachHandler", "context", "eventName", "func", "newMap", "removeAllHandlers", "callHandler", "event", "initialData", "newData", "changedProps", "prop", "changedPropsLookup", "acc", "subscriber", "changesPropsSubset", "propsToListenFor", "alreadyAdded", "args", "connect", "storeData", "storeDataSubset", "focusId", "refVal", "els", "live", "focusEl", "hydrateOnly"]
}
